var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Blackmagic DaVinci Resolve Addon for AYON","text":"<p>This is AYON integration addon for Blackmagic Design DaVinci Resolve. For more information, please visit https://ayon.ynput.io/features?addons=resolve</p>"},{"location":"license.html","title":"License","text":"<pre><code>                             Apache License\n                       Version 2.0, January 2004\n                    http://www.apache.org/licenses/\n</code></pre> <p>TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</p> <ol> <li> <p>Definitions.</p> <p>\"License\" shall mean the terms and conditions for use, reproduction,   and distribution as defined by Sections 1 through 9 of this document.</p> <p>\"Licensor\" shall mean the copyright owner or entity authorized by   the copyright owner that is granting the License.</p> <p>\"Legal Entity\" shall mean the union of the acting entity and all   other entities that control, are controlled by, or are under common   control with that entity. For the purposes of this definition,   \"control\" means (i) the power, direct or indirect, to cause the   direction or management of such entity, whether by contract or   otherwise, or (ii) ownership of fifty percent (50%) or more of the   outstanding shares, or (iii) beneficial ownership of such entity.</p> <p>\"You\" (or \"Your\") shall mean an individual or Legal Entity   exercising permissions granted by this License.</p> <p>\"Source\" form shall mean the preferred form for making modifications,   including but not limited to software source code, documentation   source, and configuration files.</p> <p>\"Object\" form shall mean any form resulting from mechanical   transformation or translation of a Source form, including but   not limited to compiled object code, generated documentation,   and conversions to other media types.</p> <p>\"Work\" shall mean the work of authorship, whether in Source or   Object form, made available under the License, as indicated by a   copyright notice that is included in or attached to the work   (an example is provided in the Appendix below).</p> <p>\"Derivative Works\" shall mean any work, whether in Source or Object   form, that is based on (or derived from) the Work and for which the   editorial revisions, annotations, elaborations, or other modifications   represent, as a whole, an original work of authorship. For the purposes   of this License, Derivative Works shall not include works that remain   separable from, or merely link (or bind by name) to the interfaces of,   the Work and Derivative Works thereof.</p> <p>\"Contribution\" shall mean any work of authorship, including   the original version of the Work and any modifications or additions   to that Work or Derivative Works thereof, that is intentionally   submitted to Licensor for inclusion in the Work by the copyright owner   or by an individual or Legal Entity authorized to submit on behalf of   the copyright owner. For the purposes of this definition, \"submitted\"   means any form of electronic, verbal, or written communication sent   to the Licensor or its representatives, including but not limited to   communication on electronic mailing lists, source code control systems,   and issue tracking systems that are managed by, or on behalf of, the   Licensor for the purpose of discussing and improving the Work, but   excluding communication that is conspicuously marked or otherwise   designated in writing by the copyright owner as \"Not a Contribution.\"</p> <p>\"Contributor\" shall mean Licensor and any individual or Legal Entity   on behalf of whom a Contribution has been received by Licensor and   subsequently incorporated within the Work.</p> </li> <li> <p>Grant of Copyright License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       copyright license to reproduce, prepare Derivative Works of,       publicly display, publicly perform, sublicense, and distribute the       Work and such Derivative Works in Source or Object form.</p> </li> <li> <p>Grant of Patent License. Subject to the terms and conditions of       this License, each Contributor hereby grants to You a perpetual,       worldwide, non-exclusive, no-charge, royalty-free, irrevocable       (except as stated in this section) patent license to make, have made,       use, offer to sell, sell, import, and otherwise transfer the Work,       where such license applies only to those patent claims licensable       by such Contributor that are necessarily infringed by their       Contribution(s) alone or by combination of their Contribution(s)       with the Work to which such Contribution(s) was submitted. If You       institute patent litigation against any entity (including a       cross-claim or counterclaim in a lawsuit) alleging that the Work       or a Contribution incorporated within the Work constitutes direct       or contributory patent infringement, then any patent licenses       granted to You under this License for that Work shall terminate       as of the date such litigation is filed.</p> </li> <li> <p>Redistribution. You may reproduce and distribute copies of the       Work or Derivative Works thereof in any medium, with or without       modifications, and in Source or Object form, provided that You       meet the following conditions:</p> <p>(a) You must give any other recipients of the Work or       Derivative Works a copy of this License; and</p> <p>(b) You must cause any modified files to carry prominent notices       stating that You changed the files; and</p> <p>(c) You must retain, in the Source form of any Derivative Works       that You distribute, all copyright, patent, trademark, and       attribution notices from the Source form of the Work,       excluding those notices that do not pertain to any part of       the Derivative Works; and</p> <p>(d) If the Work includes a \"NOTICE\" text file as part of its       distribution, then any Derivative Works that You distribute must       include a readable copy of the attribution notices contained       within such NOTICE file, excluding those notices that do not       pertain to any part of the Derivative Works, in at least one       of the following places: within a NOTICE text file distributed       as part of the Derivative Works; within the Source form or       documentation, if provided along with the Derivative Works; or,       within a display generated by the Derivative Works, if and       wherever such third-party notices normally appear. The contents       of the NOTICE file are for informational purposes only and       do not modify the License. You may add Your own attribution       notices within Derivative Works that You distribute, alongside       or as an addendum to the NOTICE text from the Work, provided       that such additional attribution notices cannot be construed       as modifying the License.</p> <p>You may add Your own copyright statement to Your modifications and   may provide additional or different license terms and conditions   for use, reproduction, or distribution of Your modifications, or   for any such Derivative Works as a whole, provided Your use,   reproduction, and distribution of the Work otherwise complies with   the conditions stated in this License.</p> </li> <li> <p>Submission of Contributions. Unless You explicitly state otherwise,       any Contribution intentionally submitted for inclusion in the Work       by You to the Licensor shall be under the terms and conditions of       this License, without any additional terms or conditions.       Notwithstanding the above, nothing herein shall supersede or modify       the terms of any separate license agreement you may have executed       with Licensor regarding such Contributions.</p> </li> <li> <p>Trademarks. This License does not grant permission to use the trade       names, trademarks, service marks, or product names of the Licensor,       except as required for reasonable and customary use in describing the       origin of the Work and reproducing the content of the NOTICE file.</p> </li> <li> <p>Disclaimer of Warranty. Unless required by applicable law or       agreed to in writing, Licensor provides the Work (and each       Contributor provides its Contributions) on an \"AS IS\" BASIS,       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or       implied, including, without limitation, any warranties or conditions       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A       PARTICULAR PURPOSE. You are solely responsible for determining the       appropriateness of using or redistributing the Work and assume any       risks associated with Your exercise of permissions under this License.</p> </li> <li> <p>Limitation of Liability. In no event and under no legal theory,       whether in tort (including negligence), contract, or otherwise,       unless required by applicable law (such as deliberate and grossly       negligent acts) or agreed to in writing, shall any Contributor be       liable to You for damages, including any direct, indirect, special,       incidental, or consequential damages of any character arising as a       result of this License or out of the use or inability to use the       Work (including but not limited to damages for loss of goodwill,       work stoppage, computer failure or malfunction, or any and all       other commercial damages or losses), even if such Contributor       has been advised of the possibility of such damages.</p> </li> <li> <p>Accepting Warranty or Additional Liability. While redistributing       the Work or Derivative Works thereof, You may choose to offer,       and charge a fee for, acceptance of support, warranty, indemnity,       or other liability obligations and/or rights consistent with this       License. However, in accepting such obligations, You may act only       on Your own behalf and on Your sole responsibility, not on behalf       of any other Contributor, and only if You agree to indemnify,       defend, and hold each Contributor harmless for any liability       incurred by, or claims asserted against, such Contributor by reason       of your accepting any such warranty or additional liability.</p> </li> </ol> <p>END OF TERMS AND CONDITIONS</p> <p>APPENDIX: How to apply the Apache License to your work.</p> <pre><code>  To apply the Apache License to your work, attach the following\n  boilerplate notice, with the fields enclosed by brackets \"[]\"\n  replaced with your own identifying information. (Don't include\n  the brackets!)  The text should be enclosed in the appropriate\n  comment syntax for the file format. We also recommend that a\n  file or class name and description of purpose be included on the\n  same \"printed page\" as the copyright notice for easier\n  identification within third-party archives.\n</code></pre> <p>Copyright [yyyy][name of copyright owner]</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <pre><code>   http://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p>"},{"location":"autoapi/summary.html","title":"Summary","text":"<ul> <li>client<ul> <li>ayon_resolve<ul> <li>addon</li> <li>api<ul> <li>action</li> <li>constants</li> <li>lib</li> <li>menu</li> <li>pipeline</li> <li>plugin</li> <li>rendering</li> <li>testing_utils</li> <li>utils</li> <li>workio</li> </ul> </li> <li>hooks<ul> <li>pre_resolve_last_workfile</li> <li>pre_resolve_setup</li> <li>pre_resolve_startup</li> </ul> </li> <li>otio<ul> <li>davinci_export</li> <li>davinci_import</li> <li>utils</li> </ul> </li> <li>plugins<ul> <li>create<ul> <li>create_editorial_package</li> <li>create_shot_clip</li> <li>create_workfile</li> </ul> </li> <li>inventory<ul> <li>remove_unused_media_pool_items</li> </ul> </li> <li>load<ul> <li>load_clip</li> <li>load_editorial_package</li> <li>load_media</li> </ul> </li> <li>publish<ul> <li>collect_audio</li> <li>collect_current_project</li> <li>collect_editorial_package</li> <li>collect_plates</li> <li>collect_shots</li> <li>extract_editorial_package</li> <li>extract_intermediate_representation</li> <li>extract_workfile</li> </ul> </li> </ul> </li> <li>startup</li> <li>utility_scripts<ul> <li>AYON__Menu</li> <li>develop<ul> <li>OTIO_export</li> <li>OTIO_import</li> <li>OpenPype_sync_util_scripts</li> <li>test_rendering_editorial_package</li> </ul> </li> </ul> </li> <li>utils</li> <li>version</li> </ul> </li> </ul> </li> <li>server<ul> <li>imageio</li> <li>settings</li> </ul> </li> </ul>"},{"location":"autoapi/client/ayon_resolve/index.html","title":"ayon_resolve","text":""},{"location":"autoapi/client/ayon_resolve/addon.html","title":"addon","text":""},{"location":"autoapi/client/ayon_resolve/startup.html","title":"startup","text":"<p>This script is used as a startup script in Resolve through a .scriptlib file</p> <p>It triggers directly after the launch of Resolve and it's recommended to keep it optimized for fast performance since the Resolve UI is actually interactive while this is running. As such, there's nothing ensuring the user isn't continuing manually before any of the logic here runs. As such we also try to delay any imports as much as possible.</p> <p>This code runs in a separate process to the main Resolve process.</p>"},{"location":"autoapi/client/ayon_resolve/startup.html#client.ayon_resolve.startup.ensure_installed_host","title":"<code>ensure_installed_host()</code>","text":"<p>Install resolve host with openpype and return the registered host.</p> <p>This function can be called multiple times without triggering an additional install.</p> Source code in <code>client/ayon_resolve/startup.py</code> <pre><code>def ensure_installed_host():\n    \"\"\"Install resolve host with openpype and return the registered host.\n\n    This function can be called multiple times without triggering an\n    additional install.\n    \"\"\"\n    from ayon_core.pipeline import install_host, registered_host\n    host = registered_host()\n    if host:\n        return host\n\n    host = ayon_resolve.api.ResolveHost()\n    install_host(host)\n    return registered_host()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_resolve/version.html","title":"version","text":"<p>Package declaring AYON addon 'resolve' version.</p>"},{"location":"autoapi/client/ayon_resolve/api/index.html","title":"api","text":"<p>resolve api</p>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ClipLoader","title":"<code>ClipLoader</code>","text":"Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class ClipLoader:\n\n    active_bin = None\n    data = {}\n\n    def __init__(self, loader_obj, context, **options):\n        \"\"\" Initialize object\n\n        Arguments:\n            loader_obj (ayon_core.pipeline.load.LoaderPlugin): plugin object\n            context (dict): loader plugin context\n            options (dict)[optional]: possible keys:\n                projectBinPath: \"path/to/binItem\"\n\n        \"\"\"\n        self.__dict__.update(loader_obj.__dict__)\n        self.context = context\n        self.active_project = lib.get_current_project()\n\n        # try to get value from options or evaluate key value for `handles`\n        self.with_handles = options.get(\"handles\") is True\n\n        # try to get value from options or evaluate key value for `load_to`\n        self.new_timeline = (\n            options.get(\"newTimeline\") or\n            options.get(\"load_to\") == \"New timeline\"\n        )\n        # try to get value from options or evaluate key value for `load_how`\n        self.sequential_load = (\n            options.get(\"sequentially\") or\n            options.get(\"load_how\") == \"Sequentially in order\"\n        )\n\n        assert self._populate_data(), str(\n            \"Cannot Load selected data, look into database \"\n            \"or call your supervisor\")\n\n        # inject asset data to representation dict\n        self._get_folder_attributes()\n\n        # add active components to class\n        if self.new_timeline:\n            loader_cls = loader_obj.__class__\n            if loader_cls.timeline:\n                # if multiselection is set then use options sequence\n                self.active_timeline = loader_cls.timeline\n            else:\n                # create new sequence\n                self.active_timeline = lib.get_new_timeline(\n                    \"{}_{}\".format(\n                        self.data[\"timeline_basename\"],\n                        str(uuid.uuid4())[:8]\n                    )\n                )\n                loader_cls.timeline = self.active_timeline\n\n        else:\n            self.active_timeline = (\n                    lib.get_current_timeline() or lib.get_new_timeline()\n            )\n\n    def _populate_data(self):\n        \"\"\" Gets context and convert it to self.data\n        data structure:\n            {\n                \"name\": \"assetName_productName_representationName\"\n                \"binPath\": \"projectBinPath\",\n            }\n        \"\"\"\n        # create name\n        folder_entity = self.context[\"folder\"]\n        product_name = self.context[\"product\"][\"name\"]\n        repre_entity = self.context[\"representation\"]\n\n        folder_name = folder_entity[\"name\"]\n        folder_path = folder_entity[\"path\"]\n        representation_name = repre_entity[\"name\"]\n\n        self.data[\"clip_name\"] = \"_\".join([\n            folder_name,\n            product_name,\n            representation_name\n        ])\n        self.data[\"versionAttributes\"] = self.context[\"version\"][\"attrib\"]\n\n        self.data[\"timeline_basename\"] = \"timeline_{}_{}\".format(\n            product_name, representation_name)\n\n        # solve project bin structure path\n        hierarchy = \"Loader{}\".format(folder_path)\n\n        self.data[\"binPath\"] = hierarchy\n\n        return True\n\n    def _get_folder_attributes(self):\n        \"\"\" Get all available asset data\n\n        joint `data` key with asset.data dict into the representation\n\n        \"\"\"\n\n        self.data[\"folderAttributes\"] = copy.deepcopy(\n            self.context[\"folder\"][\"attrib\"]\n        )\n\n    def load(self, files):\n        \"\"\"Load clip into timeline\n\n        Arguments:\n            files (list[str]): list of files to load into timeline\n        \"\"\"\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create clip media\n        media_pool_item = lib.create_media_pool_item(\n            files,\n            self.active_bin\n        )\n        _clip_property = media_pool_item.GetClipProperty\n        source_in = int(_clip_property(\"Start\"))\n        source_out = int(_clip_property(\"End\"))\n        source_duration = int(_clip_property(\"Frames\"))\n\n        # Trim clip start if slate is present\n        if \"slate\" in self.data[\"versionAttributes\"][\"families\"]:\n            source_in += 1\n            source_duration = source_out - source_in + 1\n\n        if not self.with_handles:\n            # Load file without the handles of the source media\n            # We remove the handles from the source in and source out\n            # so that the handles are excluded in the timeline\n\n            # get version data frame data from db\n            version_attributes = self.data[\"versionAttributes\"]\n            frame_start = version_attributes.get(\"frameStart\")\n            frame_end = version_attributes.get(\"frameEnd\")\n\n            # The version data usually stored the frame range + handles of the\n            # media however certain representations may be shorter because they\n            # exclude those handles intentionally. Unfortunately the\n            # representation does not store that in the database currently;\n            # so we should compensate for those cases. If the media is shorter\n            # than the frame range specified in the database we assume it is\n            # without handles and thus we do not need to remove the handles\n            # from source and out\n            if frame_start is not None and frame_end is not None:\n                # Version has frame range data, so we can compare media length\n                handle_start = version_attributes.get(\"handleStart\", 0)\n                handle_end = version_attributes.get(\"handleEnd\", 0)\n                frame_start_handle = frame_start - handle_start\n                frame_end_handle = frame_end + handle_end\n                database_frame_duration = int(\n                    frame_end_handle - frame_start_handle + 1\n                )\n                if source_duration &gt;= database_frame_duration:\n                    source_in += handle_start\n                    source_out -= handle_end\n\n        # get timeline in\n        timeline_start = self.active_timeline.GetStartFrame()\n        if self.sequential_load:\n            # set timeline start frame\n            timeline_in = int(timeline_start)\n        else:\n            # set timeline start frame + original clip in frame\n            timeline_in = int(\n                timeline_start + self.data[\"folderAttributes\"][\"clipIn\"])\n\n        # make track item from source in bin as item\n        timeline_item = lib.create_timeline_item(\n            media_pool_item,\n            self.active_timeline,\n            timeline_in,\n            source_in,\n            source_out,\n        )\n\n        print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return timeline_item\n\n    def update(self, timeline_item, files):\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create mediaItem in active project bin\n        # create clip media\n        media_pool_item = lib.create_media_pool_item(\n            files,\n            self.active_bin\n        )\n        _clip_property = media_pool_item.GetClipProperty\n\n        # Read trimming from timeline item\n        timeline_item_in = timeline_item.GetLeftOffset()\n        timeline_item_len = timeline_item.GetDuration()\n        timeline_item_out = timeline_item_in + timeline_item_len\n\n        lib.swap_clips(\n            timeline_item,\n            media_pool_item,\n            timeline_item_in,\n            timeline_item_out\n        )\n\n        print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ClipLoader.__init__","title":"<code>__init__(loader_obj, context, **options)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>loader_obj</code> <code>LoaderPlugin</code> <p>plugin object</p> required <code>context</code> <code>dict</code> <p>loader plugin context</p> required <code>options</code> <code>dict)[optional]</code> <p>possible keys: projectBinPath: \"path/to/binItem\"</p> <code>{}</code> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def __init__(self, loader_obj, context, **options):\n    \"\"\" Initialize object\n\n    Arguments:\n        loader_obj (ayon_core.pipeline.load.LoaderPlugin): plugin object\n        context (dict): loader plugin context\n        options (dict)[optional]: possible keys:\n            projectBinPath: \"path/to/binItem\"\n\n    \"\"\"\n    self.__dict__.update(loader_obj.__dict__)\n    self.context = context\n    self.active_project = lib.get_current_project()\n\n    # try to get value from options or evaluate key value for `handles`\n    self.with_handles = options.get(\"handles\") is True\n\n    # try to get value from options or evaluate key value for `load_to`\n    self.new_timeline = (\n        options.get(\"newTimeline\") or\n        options.get(\"load_to\") == \"New timeline\"\n    )\n    # try to get value from options or evaluate key value for `load_how`\n    self.sequential_load = (\n        options.get(\"sequentially\") or\n        options.get(\"load_how\") == \"Sequentially in order\"\n    )\n\n    assert self._populate_data(), str(\n        \"Cannot Load selected data, look into database \"\n        \"or call your supervisor\")\n\n    # inject asset data to representation dict\n    self._get_folder_attributes()\n\n    # add active components to class\n    if self.new_timeline:\n        loader_cls = loader_obj.__class__\n        if loader_cls.timeline:\n            # if multiselection is set then use options sequence\n            self.active_timeline = loader_cls.timeline\n        else:\n            # create new sequence\n            self.active_timeline = lib.get_new_timeline(\n                \"{}_{}\".format(\n                    self.data[\"timeline_basename\"],\n                    str(uuid.uuid4())[:8]\n                )\n            )\n            loader_cls.timeline = self.active_timeline\n\n    else:\n        self.active_timeline = (\n                lib.get_current_timeline() or lib.get_new_timeline()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ClipLoader.load","title":"<code>load(files)</code>","text":"<p>Load clip into timeline</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str]</code> <p>list of files to load into timeline</p> required Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def load(self, files):\n    \"\"\"Load clip into timeline\n\n    Arguments:\n        files (list[str]): list of files to load into timeline\n    \"\"\"\n    # create project bin for the media to be imported into\n    self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n    # create clip media\n    media_pool_item = lib.create_media_pool_item(\n        files,\n        self.active_bin\n    )\n    _clip_property = media_pool_item.GetClipProperty\n    source_in = int(_clip_property(\"Start\"))\n    source_out = int(_clip_property(\"End\"))\n    source_duration = int(_clip_property(\"Frames\"))\n\n    # Trim clip start if slate is present\n    if \"slate\" in self.data[\"versionAttributes\"][\"families\"]:\n        source_in += 1\n        source_duration = source_out - source_in + 1\n\n    if not self.with_handles:\n        # Load file without the handles of the source media\n        # We remove the handles from the source in and source out\n        # so that the handles are excluded in the timeline\n\n        # get version data frame data from db\n        version_attributes = self.data[\"versionAttributes\"]\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n\n        # The version data usually stored the frame range + handles of the\n        # media however certain representations may be shorter because they\n        # exclude those handles intentionally. Unfortunately the\n        # representation does not store that in the database currently;\n        # so we should compensate for those cases. If the media is shorter\n        # than the frame range specified in the database we assume it is\n        # without handles and thus we do not need to remove the handles\n        # from source and out\n        if frame_start is not None and frame_end is not None:\n            # Version has frame range data, so we can compare media length\n            handle_start = version_attributes.get(\"handleStart\", 0)\n            handle_end = version_attributes.get(\"handleEnd\", 0)\n            frame_start_handle = frame_start - handle_start\n            frame_end_handle = frame_end + handle_end\n            database_frame_duration = int(\n                frame_end_handle - frame_start_handle + 1\n            )\n            if source_duration &gt;= database_frame_duration:\n                source_in += handle_start\n                source_out -= handle_end\n\n    # get timeline in\n    timeline_start = self.active_timeline.GetStartFrame()\n    if self.sequential_load:\n        # set timeline start frame\n        timeline_in = int(timeline_start)\n    else:\n        # set timeline start frame + original clip in frame\n        timeline_in = int(\n            timeline_start + self.data[\"folderAttributes\"][\"clipIn\"])\n\n    # make track item from source in bin as item\n    timeline_item = lib.create_timeline_item(\n        media_pool_item,\n        self.active_timeline,\n        timeline_in,\n        source_in,\n        source_out,\n    )\n\n    print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n    return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.PublishableClip","title":"<code>PublishableClip</code>","text":"<p>Convert a track item to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>hiero.core.TrackItem: hiero track item object with openpype tag</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class PublishableClip:\n    \"\"\"\n    Convert a track item to publishable instance\n\n    Args:\n        timeline_item (hiero.core.TrackItem): hiero track item object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        hiero.core.TrackItem: hiero track item object with openpype tag\n    \"\"\"\n    tag_data = {}\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    variant_default = \"&lt;track_name&gt;\"\n    review_source_default = None\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n\n    # Define which keys of the pre create data should also be 'tag data'\n    tag_keys = {\n        # renameHierarchy\n        \"hierarchy\",\n        # hierarchyData\n        \"folder\", \"episode\", \"sequence\", \"track\", \"shot\",\n        # publish settings\n        \"audio\", \"sourceResolution\",\n        # shot attributes\n        \"workfileFrameStart\", \"handleStart\", \"handleEnd\"\n    }\n\n    def __init__(\n            self,\n            timeline_item_data: dict,\n            vertical_clip_match: dict = None,\n            vertical_clip_used: dict = None,\n            pre_create_data: dict = None,\n            media_pool_folder: str = None,\n            rename_index: int = 0,\n            data: dict = None,\n        ):\n        \"\"\" Initialize object\n\n        Args:\n            timeline_item_data (dict): timeline item data\n            pre_create_data (dict): pre create data\n            media_pool_folder (str): media pool folder\n            rename_index (int): rename index\n            data (dict): additional data\n\n        \"\"\"\n        self.vertical_clip_match = vertical_clip_match \n        self.vertical_clip_used = vertical_clip_used\n\n        self.rename_index = rename_index\n        self.tag_data = data or {}\n\n        # get main parent objects\n        self.timeline_item_data = timeline_item_data\n        self.timeline_item = timeline_item_data[\"clip\"][\"item\"]\n        timeline_name = timeline_item_data[\"timeline\"].GetName()\n        self.timeline_name = str(timeline_name).replace(\" \", \"_\")\n\n        # track item (clip) main attributes\n        self.ti_name = self.timeline_item.GetName()\n        self.ti_index = int(timeline_item_data[\"clip\"][\"index\"])\n\n        # get track name and index\n        track_name = timeline_item_data[\"track\"][\"name\"]\n        self.track_name = str(track_name).replace(\" \", \"_\")  # TODO clarify\n        self.track_index = int(timeline_item_data[\"track\"][\"index\"])\n\n        # adding ui inputs if any\n        self.pre_create_data = pre_create_data or {}\n\n        # adding media pool folder if any\n        self.media_pool_folder = media_pool_folder\n\n        # populate default data before we get other attributes\n        self._populate_timeline_item_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    def convert(self):\n        \"\"\" Convert track item to publishable instance.\n\n        Returns:\n            timeline_item (resolve.TimelineItem): timeline item with imprinted\n                data in marker\n        \"\"\"\n        # solve track item data and add them to tag data\n        self._convert_to_tag_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (\n            self.track_name in self.reviewable_source and\n            self.hero_track not in self.reviewable_source\n        ):\n            return\n\n        # deal with clip name\n        new_name = self.tag_data.pop(\"newClipName\")\n\n        if self.rename:\n            self.tag_data[\"asset\"] = new_name\n        else:\n            self.tag_data[\"asset\"] = self.ti_name\n\n        # AYON unique identifier\n        folder_path = \"/{}/{}\".format(\n            self.tag_data[\"hierarchy\"],\n            self.tag_data[\"asset\"],\n        )\n        self.tag_data[\"folderPath\"] = folder_path\n\n        if not constants.AYON_MARKER_WORKFLOW:\n            # create compound clip workflow\n            lib.create_compound_clip(\n                self.timeline_item_data,\n                self.tag_data[\"asset\"],\n                self.media_pool_folder\n            )\n\n            # add timeline_item_data selection to tag\n            self.tag_data.update({\n                \"track_data\": self.timeline_item_data[\"track\"]\n            })\n\n        return self.timeline_item\n\n    def _populate_timeline_item_default_data(self):\n        \"\"\" Populate default formatting data from track item. \"\"\"\n\n        self.timeline_item_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.timeline_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.ti_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.ti_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # track item frame range and parent track name for vertical sync check\n        self.clip_in = int(self.timeline_item.GetStart())\n        self.clip_out = int(self.timeline_item.GetEnd())\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.ti_index\n\n        # publisher ui attribute inputs or default values if gui was not used\n        def get(key):\n            \"\"\"Shorthand access for code readability\"\"\"\n            return self.pre_create_data.get(key)\n\n        self.rename = get(\"clipRename\") or self.rename_default\n        self.clip_name = get(\"clipName\") or self.clip_name_default\n        self.hierarchy = get(\"hierarchy\") or self.hierarchy_default\n        self.count_from = get(\"countFrom\") or self.count_from_default\n        self.count_steps = get(\"countSteps\") or self.count_steps_default\n        self.variant = get(\"clip_variant\") or self.variant_default\n        self.product_type = get(\"productType\") or self.product_type_default\n        self.vertical_sync = get(\"vSyncOn\") or self.vertical_sync_default\n        self.hero_track = get(\"vSyncTrack\") or self.driving_layer_default\n        self.hero_track = self.hero_track.replace(\" \", \"_\")\n        self.review_source = (\n            get(\"reviewableSource\") or self.review_source_default)\n\n        self.hierarchy_data = {\n            key: get(key) or self.timeline_item_default_data[key]\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n        # build subset name from layer name\n        if self.variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n\n        # create subset for publishing\n        # TODO: Use creator `get_subset_name` to correctly define name\n        self.product_name = self.product_type + self.variant.capitalize()\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        new_text = text.replace((\"#\" * _len), _repl)\n        return new_text\n\n    def _convert_to_tag_data(self):\n        \"\"\"Convert internal data to tag data.\n\n        Populating the tag data into internal variable self.tag_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n\n        if (\n            self.vertical_sync\n            and self.track_name not in self.hero_track\n        ):\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        _data = self.timeline_item_default_data.copy()\n        if self.pre_create_data:\n\n            # adding tag metadata from ui\n            for _key, _value in self.pre_create_data.items():\n                if _key in self.tag_keys:\n                    self.tag_data[_key] = _value\n\n            # backward compatibility for reviewableSource (2024.12.02)\n            if \"reviewTrack\" in self.pre_create_data:\n                _value = self.tag_data.pop(\"reviewTrack\")\n                self.tag_data[\"reviewableSource\"] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review track\n                if self.review_source and (\n                    self.review_source != self.review_source_default\n                ):\n                    # if review track is defined and not the same as default\n                    self.reviewable_source = self.review_source\n\n                # shot num calculate\n                if self.rename_index == 0:\n                    self.shot_num = self.count_from\n                else:\n                    self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _key, _value in self.hierarchy_data.items():\n                if \"#\" not in _value:\n                    continue\n                self.hierarchy_data[_key] = self._replace_hash_to_expression(\n                    _key, _value\n                )\n\n            # fill up pythonic expresisons in hierarchy data\n            for _key, _value in self.hierarchy_data.items():\n                hierarchy_formatting_data[_key] = _value.format(**_data)\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = self.hierarchy_data\n\n        tag_instance_data = self._solve_tag_hierarchy_data(\n            hierarchy_formatting_data\n        )\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update(\n                {\n                    (self.clip_in, self.clip_out): tag_instance_data\n                }\n            )\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\"Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = copy.deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", [])\n\n                clip_product_name = self.product_name\n                variant = self.variant\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.rename_index}\")\n                    variant = f\"{variant}{self.rename_index}\"\n\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.tag_data.update(tag_instance_data)\n\n        # add uuid to tag data\n        self.tag_data[\"uuid\"] = str(uuid.uuid4())\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.tag_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.tag_data[\"reviewTrack\"] = None\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.tag_data[\"review\"] = True\n            else:\n                self.tag_data.pop(\"review\", None)\n\n            self.tag_data[\"reviewableSource\"] = reviewable_source\n\n\n    def _solve_tag_hierarchy_data(self, hierarchy_formatting_data):\n        \"\"\" Solve tag data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type\n        }\n\n    def _convert_to_entity(self, key):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(key)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            key\n        )\n\n        return {\n            \"folder_type\": folder_type,\n            \"entity_name\": self.hierarchy_data[key].format(\n                **self.timeline_item_default_data\n            )\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n        par_split = [pattern.findall(t).pop()\n                     for t in self.hierarchy.split(\"/\")]\n\n        for key in par_split:\n            parent = self._convert_to_entity(key)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.PublishableClip.__init__","title":"<code>__init__(timeline_item_data, vertical_clip_match=None, vertical_clip_used=None, pre_create_data=None, media_pool_folder=None, rename_index=0, data=None)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>timeline item data</p> required <code>pre_create_data</code> <code>dict</code> <p>pre create data</p> <code>None</code> <code>media_pool_folder</code> <code>str</code> <p>media pool folder</p> <code>None</code> <code>rename_index</code> <code>int</code> <p>rename index</p> <code>0</code> <code>data</code> <code>dict</code> <p>additional data</p> <code>None</code> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def __init__(\n        self,\n        timeline_item_data: dict,\n        vertical_clip_match: dict = None,\n        vertical_clip_used: dict = None,\n        pre_create_data: dict = None,\n        media_pool_folder: str = None,\n        rename_index: int = 0,\n        data: dict = None,\n    ):\n    \"\"\" Initialize object\n\n    Args:\n        timeline_item_data (dict): timeline item data\n        pre_create_data (dict): pre create data\n        media_pool_folder (str): media pool folder\n        rename_index (int): rename index\n        data (dict): additional data\n\n    \"\"\"\n    self.vertical_clip_match = vertical_clip_match \n    self.vertical_clip_used = vertical_clip_used\n\n    self.rename_index = rename_index\n    self.tag_data = data or {}\n\n    # get main parent objects\n    self.timeline_item_data = timeline_item_data\n    self.timeline_item = timeline_item_data[\"clip\"][\"item\"]\n    timeline_name = timeline_item_data[\"timeline\"].GetName()\n    self.timeline_name = str(timeline_name).replace(\" \", \"_\")\n\n    # track item (clip) main attributes\n    self.ti_name = self.timeline_item.GetName()\n    self.ti_index = int(timeline_item_data[\"clip\"][\"index\"])\n\n    # get track name and index\n    track_name = timeline_item_data[\"track\"][\"name\"]\n    self.track_name = str(track_name).replace(\" \", \"_\")  # TODO clarify\n    self.track_index = int(timeline_item_data[\"track\"][\"index\"])\n\n    # adding ui inputs if any\n    self.pre_create_data = pre_create_data or {}\n\n    # adding media pool folder if any\n    self.media_pool_folder = media_pool_folder\n\n    # populate default data before we get other attributes\n    self._populate_timeline_item_default_data()\n\n    # use all populated default data to create all important attributes\n    self._populate_attributes()\n\n    # create parents with correct types\n    self._create_parents()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.PublishableClip.convert","title":"<code>convert()</code>","text":"<p>Convert track item to publishable instance.</p> <p>Returns:</p> Name Type Description <code>timeline_item</code> <code>TimelineItem</code> <p>timeline item with imprinted data in marker</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def convert(self):\n    \"\"\" Convert track item to publishable instance.\n\n    Returns:\n        timeline_item (resolve.TimelineItem): timeline item with imprinted\n            data in marker\n    \"\"\"\n    # solve track item data and add them to tag data\n    self._convert_to_tag_data()\n\n    # if track name is in review track name and also if driving track name\n    # is not in review track name: skip tag creation\n    if (\n        self.track_name in self.reviewable_source and\n        self.hero_track not in self.reviewable_source\n    ):\n        return\n\n    # deal with clip name\n    new_name = self.tag_data.pop(\"newClipName\")\n\n    if self.rename:\n        self.tag_data[\"asset\"] = new_name\n    else:\n        self.tag_data[\"asset\"] = self.ti_name\n\n    # AYON unique identifier\n    folder_path = \"/{}/{}\".format(\n        self.tag_data[\"hierarchy\"],\n        self.tag_data[\"asset\"],\n    )\n    self.tag_data[\"folderPath\"] = folder_path\n\n    if not constants.AYON_MARKER_WORKFLOW:\n        # create compound clip workflow\n        lib.create_compound_clip(\n            self.timeline_item_data,\n            self.tag_data[\"asset\"],\n            self.media_pool_folder\n        )\n\n        # add timeline_item_data selection to tag\n        self.tag_data.update({\n            \"track_data\": self.timeline_item_data[\"track\"]\n        })\n\n    return self.timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ResolveCreator","title":"<code>ResolveCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Resolve Creator class wrapper</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class ResolveCreator(Creator):\n    \"\"\" Resolve Creator class wrapper\"\"\"\n\n    marker_color = \"Purple\"\n    presets = {}\n\n    def apply_settings(self, project_settings):\n        resolve_create_settings = (\n            project_settings.get(\"resolve\", {}).get(\"create\")\n        )\n        self.presets = resolve_create_settings.get(\n            self.__class__.__name__, {}\n        )\n\n    def create(self, subset_name, instance_data, pre_create_data):\n        # adding basic current context resolve objects\n        self.project = lib.get_current_resolve_project()\n        self.timeline = lib.get_current_timeline()\n\n        if pre_create_data.get(\"use_selection\", False):\n            self.selected = lib.get_current_timeline_items(filter=True)\n        else:\n            self.selected = lib.get_current_timeline_items(filter=False)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ResolveHost","title":"<code>ResolveHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>class ResolveHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"resolve\"\n\n    def install(self):\n        \"\"\"Install resolve-specific functionality of avalon-core.\n\n        This is where you install menus and register families, data\n        and loaders into resolve.\n\n        It is called automatically when installing via `api.install(resolve)`.\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n\n        log.info(\"ayon_resolve installed\")\n\n        pyblish.register_host(self.name)\n        pyblish.register_plugin_path(PUBLISH_PATH)\n        print(\"Registering DaVinci Resolve plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # register callback for switching publishable\n        pyblish.register_callback(\"instanceToggled\",\n                                  on_pyblish_instance_toggled)\n\n        get_resolve_module()\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        # TODO: implement to support persisting context attributes\n        return {}\n\n    def update_context_data(self, data, changes):\n        # TODO: implement to support persisting context attributes\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ResolveHost.install","title":"<code>install()</code>","text":"<p>Install resolve-specific functionality of avalon-core.</p> <p>This is where you install menus and register families, data and loaders into resolve.</p> <p>It is called automatically when installing via <code>api.install(resolve)</code>.</p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install resolve-specific functionality of avalon-core.\n\n    This is where you install menus and register families, data\n    and loaders into resolve.\n\n    It is called automatically when installing via `api.install(resolve)`.\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n\n    log.info(\"ayon_resolve installed\")\n\n    pyblish.register_host(self.name)\n    pyblish.register_plugin_path(PUBLISH_PATH)\n    print(\"Registering DaVinci Resolve plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # register callback for switching publishable\n    pyblish.register_callback(\"instanceToggled\",\n                              on_pyblish_instance_toggled)\n\n    get_resolve_module()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.TimelineItemLoader","title":"<code>TimelineItemLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic SequenceLoader for Resolve</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class TimelineItemLoader(LoaderPlugin):\n    \"\"\"A basic SequenceLoader for Resolve\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Include handles\",\n            default=0,\n            help=\"Load with handles or without?\"\n        ),\n        qargparse.Choice(\n            \"load_to\",\n            label=\"Where to load clips\",\n            items=[\n                \"Current timeline\",\n                \"New timeline\"\n            ],\n            default=0,\n            help=\"Where do you want clips to be loaded?\"\n        ),\n        qargparse.Choice(\n            \"load_how\",\n            label=\"How to load clips\",\n            items=[\n                \"Original timing\",\n                \"Sequentially in order\"\n            ],\n            default=\"Original timing\",\n            help=\"Would you like to place it at original timing?\"\n        )\n    ]\n\n    def load(\n        self,\n        context,\n        name=None,\n        namespace=None,\n        options=None\n    ):\n        pass\n\n    def update(self, container, context):\n        \"\"\"Update an existing `container`\n        \"\"\"\n        pass\n\n    def remove(self, container):\n        \"\"\"Remove an existing `container`\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.TimelineItemLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing <code>container</code></p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.TimelineItemLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update an existing <code>container</code></p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.containerise","title":"<code>containerise(timeline_item, name, namespace, context, loader=None, data=None)</code>","text":"<p>Bundle Resolve's object into an assembly and imprint it with metadata</p> <p>Containerization enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>The object to containerise</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of node used to produce this container.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>timeline_item</code> <code>TimelineItem</code> <p>containerized object</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def containerise(timeline_item,\n                 name,\n                 namespace,\n                 context,\n                 loader=None,\n                 data=None):\n    \"\"\"Bundle Resolve's object into an assembly and imprint it with metadata\n\n    Containerization enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        timeline_item (resolve.TimelineItem): The object to containerise\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of node used to produce this container.\n\n    Returns:\n        timeline_item (resolve.TimelineItem): containerized object\n\n    \"\"\"\n\n    data_imprint = OrderedDict({\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": str(name),\n        \"namespace\": str(namespace),\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    })\n\n    if data:\n        data_imprint.update(data)\n\n    lib.set_timeline_item_ayon_tag(timeline_item, data_imprint)\n\n    return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.create_bin","title":"<code>create_bin(name, root=None, set_as_current=True)</code>","text":"<p>Create media pool's folder.</p> <p>Return folder object and if the name does not exist it will create a new. If the input name is with forward or backward slashes then it will create all parents and return the last child bin object</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of folder / bin, or hierarchycal name \"parent/name\"</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <code>set_as_current</code> <code>resolve.Folder)[optional]</code> <p>Whether to set the resulting bin as current folder or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.Folder</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_bin(name: str,\n               root: object = None,\n               set_as_current: bool = True) -&gt; object:\n    \"\"\"\n    Create media pool's folder.\n\n    Return folder object and if the name does not exist it will create a new.\n    If the input name is with forward or backward slashes then it will create\n    all parents and return the last child bin object\n\n    Args:\n        name (str): name of folder / bin, or hierarchycal name \"parent/name\"\n        root (resolve.Folder)[optional]: root folder / bin object\n        set_as_current (resolve.Folder)[optional]: Whether to set the\n            resulting bin as current folder or not.\n\n    Returns:\n        object: resolve.Folder\n    \"\"\"\n    # get all variables\n    media_pool = get_current_resolve_project().GetMediaPool()\n    root_bin = root or media_pool.GetRootFolder()\n\n    # create hierarchy of bins in case there is slash in name\n    if \"/\" in name.replace(\"\\\\\", \"/\"):\n        child_bin = None\n        for bname in name.split(\"/\"):\n            child_bin = create_bin(bname,\n                                   root=child_bin or root_bin,\n                                   set_as_current=set_as_current)\n        if child_bin:\n            return child_bin\n    else:\n        # Find existing folder or create it\n        for subfolder in root_bin.GetSubFolderList():\n            if subfolder.GetName() == name:\n                created_bin = subfolder\n                break\n        else:\n            created_bin = media_pool.AddSubFolder(root_bin, name)\n\n        if set_as_current:\n            media_pool.SetCurrentFolder(created_bin)\n\n        return created_bin\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.create_compound_clip","title":"<code>create_compound_clip(clip_data, name, folder)</code>","text":"<p>Convert timeline object into nested timeline object</p> <p>Parameters:</p> Name Type Description Default <code>clip_data</code> <code>dict</code> <p>timeline item object packed into dict               with project, timeline (sequence)</p> required <code>folder</code> <code>Folder</code> <p>media pool folder object,</p> required <code>name</code> <code>str</code> <p>name for compound clip</p> required <p>Returns:</p> Type Description <p>resolve.MediaPoolItem: media pool item with compound clip timeline(cct)</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_compound_clip(clip_data, name, folder):\n    \"\"\"\n    Convert timeline object into nested timeline object\n\n    Args:\n        clip_data (dict): timeline item object packed into dict\n                          with project, timeline (sequence)\n        folder (resolve.MediaPool.Folder): media pool folder object,\n        name (str): name for compound clip\n\n    Returns:\n        resolve.MediaPoolItem: media pool item with compound clip timeline(cct)\n    \"\"\"\n    # get basic objects form data\n    resolve_project = clip_data[\"project\"]\n    timeline = clip_data[\"timeline\"]\n    clip = clip_data[\"clip\"]\n\n    # get details of objects\n    clip_item = clip[\"item\"]\n\n    mp = resolve_project.GetMediaPool()\n\n    # get clip attributes\n    clip_attributes = get_clip_attributes(clip_item)\n\n    mp_item = clip_item.GetMediaPoolItem()\n    _mp_props = mp_item.GetClipProperty\n\n    mp_first_frame = int(_mp_props(\"Start\"))\n    mp_last_frame = int(_mp_props(\"End\"))\n\n    # initialize basic source timing for otio\n    ci_l_offset = clip_item.GetLeftOffset()\n    ci_duration = clip_item.GetDuration()\n    rate = float(_mp_props(\"FPS\"))\n\n    # source rational times\n    mp_in_rc = otio.opentime.RationalTime((ci_l_offset), rate)\n    mp_out_rc = otio.opentime.RationalTime((ci_l_offset + ci_duration - 1), rate)\n\n    # get frame in and out for clip swapping\n    in_frame = otio.opentime.to_frames(mp_in_rc)\n    out_frame = otio.opentime.to_frames(mp_out_rc)\n\n    # keep original sequence\n    tl_origin = timeline\n\n    # Set current folder to input media_pool_folder:\n    mp.SetCurrentFolder(folder)\n\n    # check if clip doesn't exist already:\n    clips = folder.GetClipList()\n    cct = next((c for c in clips\n                if c.GetName() in name), None)\n\n    if cct:\n        print(f\"Compound clip exists: {cct}\")\n    else:\n        # Create empty timeline in current folder and give name:\n        cct = mp.CreateEmptyTimeline(name)\n\n        # check if clip doesn't exist already:\n        clips = folder.GetClipList()\n        cct = next((c for c in clips\n                    if c.GetName() in name), None)\n        print(f\"Compound clip created: {cct}\")\n\n        with maintain_current_timeline(cct, tl_origin):\n            # Add input clip to the current timeline:\n            mp.AppendToTimeline([{\n                \"mediaPoolItem\": mp_item,\n                \"startFrame\": mp_first_frame,\n                \"endFrame\": mp_last_frame\n            }])\n\n    # Add collected metadata and attributes to the compound clip:\n    if mp_item.GetMetadata(constants.AYON_TAG_NAME):\n        clip_attributes[constants.AYON_TAG_NAME] = mp_item.GetMetadata(\n            constants.AYON_TAG_NAME)[constants.AYON_TAG_NAME]\n\n    # stringify\n    clip_attributes = json.dumps(clip_attributes)\n\n    # add attributes to metadata\n    for k, v in mp_item.GetMetadata().items():\n        cct.SetMetadata(k, v)\n\n    # add metadata to cct\n    cct.SetMetadata(constants.AYON_TAG_NAME, clip_attributes)\n\n    # reset start timecode of the compound clip\n    cct.SetClipProperty(\"Start TC\", _mp_props(\"Start TC\"))\n\n    # swap clips on timeline\n    swap_clips(clip_item, cct, in_frame, out_frame)\n\n    cct.SetClipColor(\"Pink\")\n    return cct\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.create_media_pool_item","title":"<code>create_media_pool_item(files, root=None)</code>","text":"<p>Create media pool item.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list</code> <p>absolute path to a file</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.MediaPoolItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_media_pool_item(files: list,\n                           root: object = None) -&gt; object:\n    \"\"\" Create media pool item.\n\n    Args:\n        files (list): absolute path to a file\n        root (resolve.Folder)[optional]: root folder / bin object\n\n    Returns:\n        object: resolve.MediaPoolItem\n    \"\"\"\n    # get all variables\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    root_bin = root or media_pool.GetRootFolder()\n\n    # make sure files list is not empty and first available file exists\n    filepath = next((f for f in files if os.path.isfile(f)), None)\n    if not filepath:\n        raise FileNotFoundError(\"No file found in input files list\")\n\n    # try to search in bin if the clip does not exist\n    existing_mpi = get_media_pool_item(filepath, root_bin)\n\n    if existing_mpi:\n        return existing_mpi\n\n    # add media to media-pool\n    media_pool_items = media_pool.ImportMedia(files)\n\n    if not media_pool_items:\n        return False\n\n    # return only first found\n    return media_pool_items.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.create_timeline_item","title":"<code>create_timeline_item(media_pool_item, timeline=None, timeline_in=None, source_start=None, source_end=None)</code>","text":"<p>Add media pool item to current or defined timeline.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>resolve's object</p> required <code>timeline</code> <code>Optional[Timeline]</code> <p>resolve's object</p> <code>None</code> <code>timeline_in</code> <code>Optional[int]</code> <p>timeline input frame (sequence frame)</p> <code>None</code> <code>source_start</code> <code>Optional[int]</code> <p>media source input frame (sequence frame)</p> <code>None</code> <code>source_end</code> <code>Optional[int]</code> <p>media source output frame (sequence frame)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_timeline_item(\n        media_pool_item: object,\n        timeline: object = None,\n        timeline_in: int = None,\n        source_start: int = None,\n        source_end: int = None,\n) -&gt; object:\n    \"\"\"\n    Add media pool item to current or defined timeline.\n\n    Args:\n        media_pool_item (resolve.MediaPoolItem): resolve's object\n        timeline (Optional[resolve.Timeline]): resolve's object\n        timeline_in (Optional[int]): timeline input frame (sequence frame)\n        source_start (Optional[int]): media source input frame (sequence frame)\n        source_end (Optional[int]): media source output frame (sequence frame)\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    # get all variables\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    clip_name = media_pool_item.GetClipProperty(\"File Name\")\n    timeline = timeline or get_current_timeline()\n\n    # timing variables\n    if all([\n        timeline_in is not None,\n        source_start is not None,\n        source_end is not None\n    ]):\n        fps = timeline.GetSetting(\"timelineFrameRate\")\n        duration = source_end - source_start\n        timecode_in = frames_to_timecode(timeline_in, fps)\n        timecode_out = frames_to_timecode(timeline_in + duration, fps)\n    else:\n        timecode_in = None\n        timecode_out = None\n\n    # if timeline was used then switch it to current timeline\n    with maintain_current_timeline(timeline):\n        # Add input mediaPoolItem to clip data\n        clip_data = {\n            \"mediaPoolItem\": media_pool_item,\n        }\n\n        if source_start:\n            clip_data[\"startFrame\"] = source_start\n        if source_end:\n            clip_data[\"endFrame\"] = source_end\n        if timecode_in:\n            # Note: specifying a recordFrame will fail to place the timeline\n            #  item if there's already an existing clip at that time on the\n            #  active track.\n            clip_data[\"recordFrame\"] = timeline_in\n\n        # add to timeline\n        output_timeline_item = media_pool.AppendToTimeline([clip_data])[0]\n\n        # Adding the item may fail whilst Resolve will still return a\n        # TimelineItem instance - however all `Get*` calls return None\n        # Hence, we check whether the result is valid\n        if output_timeline_item.GetDuration() is None:\n            output_timeline_item = None\n\n    assert output_timeline_item, AssertionError((\n        \"Clip name '{}' wasn't created on the timeline: '{}' \\n\\n\"\n        \"Please check if correct track position is activated, \\n\"\n        \"or if a clip is not already at the timeline in \\n\"\n        \"position: '{}' out: '{}'. \\n\\n\"\n        \"Clip data: {}\"\n    ).format(\n        clip_name, timeline.GetName(), timecode_in, timecode_out, clip_data\n    ))\n    return output_timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.export_timeline_otio","title":"<code>export_timeline_otio(timeline)</code>","text":"<p>Export timeline as otio.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>resolve's timeline</p> required <p>Returns:</p> Name Type Description <code>otio_timeline</code> <code>Timeline</code> <p>Otio timeline.</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def export_timeline_otio(timeline):\n    \"\"\" Export timeline as otio.\n\n    Args:\n        timeline (resolve.Timeline): resolve's timeline\n\n    Returns:\n        otio_timeline (otio.Timeline): Otio timeline.\n    \"\"\"\n    # DaVinci Resolve &lt;= 18.5\n    # Legacy export (slower) through AYON.\n    if not hasattr(timeline, \"Export\"):\n        return otio_export.create_otio_timeline(\n            get_current_resolve_project(),\n            timeline=timeline\n        )\n\n    # DaVinci Resolve &gt;= 18.5\n    # Force export through a temporary file (native)\n    temp_otio_file = _get_otio_temp_file(timeline=timeline)\n    export_timeline_otio_to_file(timeline, temp_otio_file)\n    otio_timeline = otio.adapters.read_from_file(temp_otio_file)\n\n    return otio_timeline\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.export_timeline_otio_to_file","title":"<code>export_timeline_otio_to_file(timeline, filepath)</code>","text":"<p>Export timeline as otio filepath.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>resolve's timeline</p> required <code>filepath</code> <code>str</code> <p>otio file path</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>temporary otio filepath</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def export_timeline_otio_to_file(timeline, filepath):\n    \"\"\"Export timeline as otio filepath.\n\n    Args:\n        timeline (resolve.Timeline): resolve's timeline\n        filepath (str): otio file path\n\n    Returns:\n        str: temporary otio filepath\n    \"\"\"\n    try:\n        from . import bmdvr\n\n        if bmdvr.EXPORT_OTIO is None:\n            raise AttributeError(\"Unsupported native Export OTIO\")\n\n        timeline.Export(filepath, bmdvr.EXPORT_OTIO)\n\n    except Exception as error:\n        log.debug(\n            \"Cannot use native OTIO export (%r).\"\n            \"Default to AYON own implementation.\",\n            error\n        )\n        otio_timeline = otio_export.create_otio_timeline(\n            get_current_resolve_project(),\n            timeline=timeline\n        )\n        otio_export.write_to_file(otio_timeline, filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_any_timeline","title":"<code>get_any_timeline()</code>","text":"<p>Get any timeline object.</p> <p>Returns:</p> Type Description <p>object | None: resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_any_timeline():\n    \"\"\"Get any timeline object.\n\n    Returns:\n        object | None: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    timeline_count = resolve_project.GetTimelineCount()\n    if timeline_count &gt; 0:\n        return resolve_project.GetTimelineByIndex(1)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_clip_resolution_from_media_pool","title":"<code>get_clip_resolution_from_media_pool(timeline_item_data)</code>","text":"<p>Return the clip resolution from media pool data.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>Timeline item to investigate.</p> required <p>Returns:</p> Name Type Description <code>resolution_info</code> <code>dict</code> <p>The parsed resolution data.</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_clip_resolution_from_media_pool(timeline_item_data):\n    \"\"\"Return the clip resolution from media pool data.\n\n    Args:\n        timeline_item_data (dict): Timeline item to investigate.\n\n    Returns:\n        resolution_info (dict): The parsed resolution data.\n    \"\"\"\n    clip_item = timeline_item_data[\"clip\"][\"item\"]\n    media_pool_item = clip_item.GetMediaPoolItem()\n    clip_properties = media_pool_item.GetClipProperty()\n\n    try:\n        width, height = clip_properties[\"Resolution\"].split(\"x\")\n    except (KeyError, ValueError):\n        width = height = None\n\n    try:\n        clip_par = clip_properties[\"PAR\"]  # Pixel Aspect Resolution\n        pixel_aspect = constants.PAR_VALUES[clip_par]\n\n    except (KeyError, ValueError):  # Unknown or undetected PAR\n        pixel_aspect = 1.0\n\n    return {\"width\": width, \"height\": height, \"pixelAspect\": pixel_aspect}\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_current_resolve_project","title":"<code>get_current_resolve_project()</code>","text":"<p>Get current resolve project object.</p> <p>Returns:</p> Type Description <p>resolve.Project</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_resolve_project():\n    \"\"\"Get current resolve project object.\n\n    Returns:\n        resolve.Project\n    \"\"\"\n    project_manager = get_project_manager()\n    return project_manager.GetCurrentProject()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_current_timeline","title":"<code>get_current_timeline(new=False)</code>","text":"<p>Get current timeline object.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>bool)[optional]</code> <p>[DEPRECATED] if True it will create new timeline if none exists</p> <code>False</code> <p>Returns:</p> Type Description <p>object | None: resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_timeline(new=False):\n    \"\"\"Get current timeline object.\n\n    Args:\n        new (bool)[optional]: [DEPRECATED] if True it will create\n            new timeline if none exists\n\n    Returns:\n        object | None: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    timeline = resolve_project.GetCurrentTimeline()\n\n    # return current timeline if any\n    if timeline:\n        return timeline\n\n    # TODO: [deprecated] and will be removed in future\n    if new:\n        return get_new_timeline()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_current_timeline_items","title":"<code>get_current_timeline_items(filter=False, track_type=None, track_name=None, selecting_color=None)</code>","text":"<p>Get all available current timeline track items</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_timeline_items(\n        filter: bool = False,\n        track_type: str = None,\n        track_name: str = None,\n        selecting_color: str = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all available current timeline track items\"\"\"\n    track_type = track_type or \"video\"\n    selecting_color = selecting_color or constants.SELECTED_CLIP_COLOR\n    resolve_project = get_current_resolve_project()\n\n    # get timeline anyhow\n    timeline = get_current_timeline() or get_any_timeline()\n    if not timeline:\n        return []\n\n    selected_clips = []\n\n    # get all tracks count filtered by track type\n    selected_track_count = timeline.GetTrackCount(track_type)\n\n    # loop all tracks and get items\n    _clips = {}\n    for track_index in range(1, (int(selected_track_count) + 1)):\n        _track_name = timeline.GetTrackName(track_type, track_index)\n\n        # filter out all unmatched track names\n        if track_name and _track_name not in track_name:\n            continue\n\n        timeline_items = timeline.GetItemListInTrack(track_type, track_index)\n        _clips[track_index] = timeline_items\n\n        _data = {\n            \"project\": resolve_project,\n            \"timeline\": timeline,\n            \"track\": {\n                \"name\": _track_name,\n                \"index\": track_index,\n                \"type\": track_type}\n        }\n        # get track item object and its color\n        for clip_index, ti in enumerate(_clips[track_index]):\n            data = _data.copy()\n            data[\"clip\"] = {\n                \"item\": ti,\n                \"index\": clip_index\n            }\n            ti_color = ti.GetClipColor()\n            if filter and selecting_color in ti_color or not filter:\n                selected_clips.append(data)\n    return selected_clips\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_media_pool_item","title":"<code>get_media_pool_item(filepath, root=None)</code>","text":"<p>Return clip if found in folder with use of input file path.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>absolute path to a file</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.MediaPoolItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_media_pool_item(filepath, root: object = None) -&gt; object:\n    \"\"\"\n    Return clip if found in folder with use of input file path.\n\n    Args:\n        filepath (str): absolute path to a file\n        root (resolve.Folder)[optional]: root folder / bin object\n\n    Returns:\n        object: resolve.MediaPoolItem\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    root = root or media_pool.GetRootFolder()\n    fname = os.path.basename(filepath)\n\n    for _mpi in root.GetClipList():\n        _mpi_name = _mpi.GetClipProperty(\"File Name\")\n        _mpi_name = get_reformated_path(_mpi_name, first=True)\n        if fname in _mpi_name:\n            return _mpi\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_new_timeline","title":"<code>get_new_timeline(timeline_name=None)</code>","text":"<p>Get new timeline object.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_name</code> <code>str</code> <p>New timeline name.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <p>resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_new_timeline(timeline_name: str = None):\n    \"\"\"Get new timeline object.\n\n    Arguments:\n        timeline_name (str): New timeline name.\n\n    Returns:\n        object: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    new_timeline = media_pool.CreateEmptyTimeline(\n        timeline_name or constants.AYON_TIMELINE_NAME)\n    resolve_project.SetCurrentTimeline(new_timeline)\n    return new_timeline\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_otio_clip_instance_data","title":"<code>get_otio_clip_instance_data(otio_timeline, timeline_item_data)</code>","text":"<p>Return otio objects for timeline, track and clip</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>timeline_item_data from list returned by                     resolve.get_current_timeline_items()</p> required <code>otio_timeline</code> <code>Timeline</code> <p>otio object</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>otio clip object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_otio_clip_instance_data(otio_timeline, timeline_item_data):\n    \"\"\"\n    Return otio objects for timeline, track and clip\n\n    Args:\n        timeline_item_data (dict): timeline_item_data from list returned by\n                                resolve.get_current_timeline_items()\n        otio_timeline (otio.schema.Timeline): otio object\n\n    Returns:\n        dict: otio clip object\n\n    \"\"\"\n\n    timeline_item = timeline_item_data[\"clip\"][\"item\"]\n    track_name = timeline_item_data[\"track\"][\"name\"]\n    timeline_range = create_otio_time_range_from_timeline_item_data(\n        timeline_item_data)\n\n    try:  # opentimelineio &gt;= 0.16.0\n        all_clips = otio_timeline.find_clips()\n    except AttributeError:  # legacy\n        all_clips = otio_timeline.each_clip()\n\n    for otio_clip in all_clips:\n        track_name = otio_clip.parent().name\n        parent_range = otio_clip.range_in_parent()\n        if track_name not in track_name:\n            continue\n        if otio_clip.name not in timeline_item.GetName():\n            continue\n        if is_overlapping_otio_ranges(\n                parent_range, timeline_range, strict=True):\n\n            # add pypedata marker to otio_clip metadata\n            for marker in otio_clip.markers:\n                if constants.AYON_MARKER_NAME in marker.name:\n                    otio_clip.metadata.update(marker.metadata)\n            return {\"otioClip\": otio_clip}\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_project_manager","title":"<code>get_project_manager()</code>","text":"<p>Get project manager object.</p> <p>Returns:</p> Type Description <p>resolve.ProjectManager</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_project_manager():\n    \"\"\"Get project manager object.\n\n    Returns:\n        resolve.ProjectManager\n    \"\"\"\n    from . import bmdvr, project_manager\n    if not project_manager:\n        project_manager = bmdvr.GetProjectManager()\n\n    return project_manager\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_publish_attribute","title":"<code>get_publish_attribute(timeline_item)</code>","text":"<p>Get Publish attribute from marker on timeline item</p> Attribute <p>timeline_item (resolve.TimelineItem): resolve's object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_publish_attribute(timeline_item):\n    \"\"\" Get Publish attribute from marker on timeline item\n\n    Attribute:\n        timeline_item (resolve.TimelineItem): resolve's object\n    \"\"\"\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n    return tag_data[\"publish\"]\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_pype_clip_metadata","title":"<code>get_pype_clip_metadata(clip)</code>","text":"<p>Get AYON metadata created by creator plugin</p> <p>Attributes:</p> Name Type Description <code>clip</code> <code>TimelineItem</code> <p>resolve's object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>hierarchy, orig clip attributes</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_pype_clip_metadata(clip):\n    \"\"\"\n    Get AYON metadata created by creator plugin\n\n    Attributes:\n        clip (resolve.TimelineItem): resolve's object\n\n    Returns:\n        dict: hierarchy, orig clip attributes\n    \"\"\"\n    mp_item = clip.GetMediaPoolItem()\n    metadata = mp_item.GetMetadata()\n\n    return metadata.get(constants.AYON_TAG_NAME)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_reformated_path","title":"<code>get_reformated_path(path, padded=False, first=False)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_reformated_path(path, padded=False, first=False):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    first_frame_pattern = re.compile(r\"\\[(\\d+)\\-\\d+\\]\")\n\n    if \"[\" in path:\n        padding_pattern = r\"(\\d+)(?=-)\"\n        padding = len(re.findall(padding_pattern, path).pop())\n        num_pattern = r\"(\\[\\d+\\-\\d+\\])\"\n        if padded:\n            path = re.sub(num_pattern, f\"%0{padding}d\", path)\n        elif first:\n            first_frame = re.findall(first_frame_pattern, path, flags=0)\n            if len(first_frame) &gt;= 1:\n                first_frame = first_frame[0]\n            path = re.sub(num_pattern, first_frame, path)\n        else:\n            path = re.sub(num_pattern, \"%d\", path)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_timeline_item","title":"<code>get_timeline_item(media_pool_item, timeline=None)</code>","text":"<p>Returns clips related to input mediaPoolItem.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>resolve's object</p> required <code>timeline</code> <code>resolve.Timeline)[optional]</code> <p>resolve's object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item(media_pool_item: object,\n                      timeline: object = None) -&gt; object:\n    \"\"\"\n    Returns clips related to input mediaPoolItem.\n\n    Args:\n        media_pool_item (resolve.MediaPoolItem): resolve's object\n        timeline (resolve.Timeline)[optional]: resolve's object\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    clip_name = media_pool_item.GetClipProperty(\"File Name\")\n    output_timeline_item = None\n    timeline = timeline or get_current_timeline()\n\n    with maintain_current_timeline(timeline):\n        # search the timeline for the added clip\n\n        for ti_data in get_current_timeline_items():\n            ti_clip_item = ti_data[\"clip\"][\"item\"]\n            ti_media_pool_item = ti_clip_item.GetMediaPoolItem()\n\n            # Skip items that do not have a media pool item, like for example\n            # an \"Adjustment Clip\" or a \"Fusion Composition\" from the effects\n            # toolbox\n            if not ti_media_pool_item:\n                continue\n\n            if clip_name in ti_media_pool_item.GetClipProperty(\"File Name\"):\n                output_timeline_item = ti_clip_item\n\n    return output_timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_timeline_item_ayon_tag","title":"<code>get_timeline_item_ayon_tag(timeline_item)</code>","text":"<p>Get ayon track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TimelineItem</code> <p>resolve object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>ayon tag data</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item_ayon_tag(timeline_item):\n    \"\"\"\n    Get ayon track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (resolve.TimelineItem): resolve object\n\n    Returns:\n        dict: ayon tag data\n    \"\"\"\n    return_tag = None\n\n    if constants.AYON_MARKER_WORKFLOW:\n        return_tag = get_ayon_marker(timeline_item)\n    else:\n        media_pool_item = timeline_item.GetMediaPoolItem()\n\n        # get all tags from track item\n        _tags = media_pool_item.GetMetadata()\n        if not _tags:\n            return None\n        for key, data in _tags.items():\n            # return only correct tag defined by global name\n            if key in constants.AYON_TAG_NAME:\n                return_tag = json.loads(data)\n\n    return return_tag\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.get_timeline_item_by_name","title":"<code>get_timeline_item_by_name(name)</code>","text":"<p>Get timeline item by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of timeline item</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item_by_name(name: str) -&gt; object:\n    \"\"\"Get timeline item by name.\n\n    Args:\n        name (str): name of timeline item\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    for _ti_data in get_current_timeline_items():\n        _ti_clip = _ti_data[\"clip\"][\"item\"]\n        tag_data = get_timeline_item_pype_tag(_ti_clip)\n        tag_name = tag_data.get(\"namespace\")\n        if not tag_name:\n            continue\n        if tag_name in name:\n            return _ti_clip\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.imprint","title":"<code>imprint(timeline_item, data=None)</code>","text":"<p>Adding <code>Ayon data</code> into a timeline item track item tag.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>resolve's object</p> required <code>data</code> <code>dict</code> <p>Any data which needs to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'asset': 'sq020sh0280',     'family': 'render',     'subset': 'subsetMain' }</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def imprint(timeline_item, data=None):\n    \"\"\"\n    Adding `Ayon data` into a timeline item track item tag.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        timeline_item (resolve.TimelineItem): resolve's object\n        data (dict): Any data which needs to be imprinted\n\n    Examples:\n        data = {\n            'asset': 'sq020sh0280',\n            'family': 'render',\n            'subset': 'subsetMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_timeline_item_ayon_tag(timeline_item, data)\n\n    # add publish attribute\n    set_publish_attribute(timeline_item, True)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> <p>This function is used by the Container Manager in Nuke. You'll need to implement a for-loop that then yields one Container at a time.</p> <p>See the <code>container.json</code> schema for details on how it should look, and the Maya equivalent, which is in <code>avalon.maya.pipeline</code></p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n\n    This function is used by the Container Manager in Nuke. You'll\n    need to implement a for-loop that then *yields* one Container at\n    a time.\n\n    See the `container.json` schema for details on how it should look,\n    and the Maya equivalent, which is in `avalon.maya.pipeline`\n    \"\"\"\n\n    # Media Pool instances from Load Media loader\n    for clip in lib.iter_all_media_pool_clips():\n        data = clip.GetMetadata(constants.AYON_TAG_NAME)\n        if not data:\n            continue\n\n        try:\n            data = json.loads(data)\n        except json.JSONDecodeError:\n            log.warning(\n                f\"Failed to parse json data from media pool item: \"\n                f\"{clip.GetName()}\"\n            )\n            continue\n\n        # treat data as container\n        # There might be cases where clip's metadata are having additional\n        # because it needs to store 'load' and 'publish' data. In that case\n        # we need to get only 'load' data\n        if data.get(\"load\"):\n            data = data[\"load\"]\n\n        # If not all required data, skip it\n        required = ['schema', 'id', 'loader', 'representation']\n        if not all(key in data for key in required):\n            continue\n\n        container = {key: data[key] for key in required}\n        container[\"objectName\"] = clip.GetName()  # Get path in folders\n        container[\"namespace\"] = clip.GetName()\n        container[\"name\"] = clip.GetUniqueId()\n        container[\"_item\"] = clip\n        yield container\n\n    # Timeline instances from Load Clip loader\n    # get all track items from current timeline\n    all_timeline_items = lib.get_current_timeline_items(filter=False)\n\n    for timeline_item_data in all_timeline_items:\n        timeline_item = timeline_item_data[\"clip\"][\"item\"]\n        container = parse_container(timeline_item)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.maintain_current_timeline","title":"<code>maintain_current_timeline(to_timeline, from_timeline=None)</code>","text":"<p>Maintain current timeline selection during context</p> <p>Attributes:</p> Name Type Description <code>from_timeline</code> <code>resolve.Timeline)[optional]</code> <p>Example:     &gt;&gt;&gt; print(from_timeline.GetName())     timeline1     &gt;&gt;&gt; print(to_timeline.GetName())     timeline2</p> <pre><code>&gt;&gt;&gt; with maintain_current_timeline(to_timeline):\n...     print(get_current_timeline().GetName())\ntimeline2\n\n&gt;&gt;&gt; print(get_current_timeline().GetName())\ntimeline1\n</code></pre> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintain_current_timeline(to_timeline: object,\n                              from_timeline: object = None):\n    \"\"\"Maintain current timeline selection during context\n\n    Attributes:\n        from_timeline (resolve.Timeline)[optional]:\n    Example:\n        &gt;&gt;&gt; print(from_timeline.GetName())\n        timeline1\n        &gt;&gt;&gt; print(to_timeline.GetName())\n        timeline2\n\n        &gt;&gt;&gt; with maintain_current_timeline(to_timeline):\n        ...     print(get_current_timeline().GetName())\n        timeline2\n\n        &gt;&gt;&gt; print(get_current_timeline().GetName())\n        timeline1\n    \"\"\"\n    project = get_current_resolve_project()\n    working_timeline = from_timeline or project.GetCurrentTimeline()\n\n    # search timeline withing project timelines in case the\n    # to_timeline is MediaPoolItem\n    # Note: this is a hacky way of identifying if object is timeline since\n    #   mediapool item is not having AddTrack attribute. API is not providing\n    #   any other way to identify the object type. And hasattr is returning\n    #   false info.\n    if \"AddTrack\" not in dir(to_timeline):\n        tcount = project.GetTimelineCount()\n        for idx in range(0, int(tcount)):\n            timeline = project.GetTimelineByIndex(idx + 1)\n            if timeline.GetName() == to_timeline.GetName():\n                to_timeline = timeline\n                break\n\n    try:\n        # switch to the input timeline\n        result = project.SetCurrentTimeline(to_timeline)\n        if not result:\n            raise ValueError(f\"Failed to switch to timeline: {to_timeline}\")\n\n        current_timeline = project.GetCurrentTimeline()\n        yield current_timeline\n    finally:\n        # put the original working timeline to context\n        project.SetCurrentTimeline(working_timeline)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     node['selected'].setValue(True) print(node['selected'].value()) False</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     node['selected'].setValue(True)\n        &gt;&gt;&gt; print(node['selected'].value())\n        False\n    \"\"\"\n    try:\n        # do the operation\n        yield\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Loading project</p> Source code in <code>client/ayon_resolve/api/workio.py</code> <pre><code>def open_file(filepath):\n    \"\"\"\n    Loading project\n    \"\"\"\n\n    from . import bmdvr\n\n    project_manager = get_project_manager()\n    page = bmdvr.GetCurrentPage()\n    if page is not None:\n        # Save current project only if Resolve has an active page, otherwise\n        # we consider Resolve being in a pre-launch state (no open UI yet)\n        resolve_project = get_current_resolve_project()\n        print(f\"Saving current resolve project: {resolve_project}\")\n        project_manager.SaveProject()\n\n    file = os.path.basename(filepath)\n    fname, _ = os.path.splitext(file)\n\n    try:\n        # load project from input path\n        resolve_project = project_manager.LoadProject(fname)\n        log.info(f\"Project {resolve_project.GetName()} opened...\")\n\n    except AttributeError:\n        log.warning((f\"Project with name `{fname}` does not exist! It will \"\n                     f\"be imported from {filepath} and then loaded...\"))\n        if project_manager.ImportProject(filepath):\n            # load project from input path\n            resolve_project = project_manager.LoadProject(fname)\n            log.info(f\"Project imported/loaded {resolve_project.GetName()}...\")\n            return True\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.set_project_manager_to_folder_name","title":"<code>set_project_manager_to_folder_name(folder_name)</code>","text":"<p>Sets context of Project manager to given folder by name.</p> <p>Searching for folder by given name from root folder to nested. If no existing folder by name it will create one in root folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder_name</code> <code>str</code> <p>name of searched folder</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if success</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Cannot create folder in root</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_project_manager_to_folder_name(folder_name):\n    \"\"\"\n    Sets context of Project manager to given folder by name.\n\n    Searching for folder by given name from root folder to nested.\n    If no existing folder by name it will create one in root folder.\n\n    Args:\n        folder_name (str): name of searched folder\n\n    Returns:\n        bool: True if success\n\n    Raises:\n        Exception: Cannot create folder in root\n\n    \"\"\"\n    # initialize project manager\n    project_manager = get_project_manager()\n\n    set_folder = False\n\n    # go back to root folder\n    if project_manager.GotoRootFolder():\n        log.info(f\"Testing existing folder: {folder_name}\")\n        folders = _convert_resolve_list_type(\n            project_manager.GetFoldersInCurrentFolder())\n        log.info(f\"Testing existing folders: {folders}\")\n        # get me first available folder object\n        # with the same name as in `folder_name` else return False\n        if next((f for f in folders if f in folder_name), False):\n            log.info(f\"Found existing folder: {folder_name}\")\n            set_folder = project_manager.OpenFolder(folder_name)\n\n    if set_folder:\n        return True\n\n    # if folder by name is not existent then create one\n    # go back to root folder\n    log.info(f\"Folder `{folder_name}` not found and will be created\")\n    if project_manager.GotoRootFolder():\n        try:\n            # create folder by given name\n            project_manager.CreateFolder(folder_name)\n            project_manager.OpenFolder(folder_name)\n            return True\n        except NameError as e:\n            log.error((f\"Folder with name `{folder_name}` cannot be created!\"\n                       f\"Error: {e}\"))\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.set_publish_attribute","title":"<code>set_publish_attribute(timeline_item, value)</code>","text":"<p>Set Publish attribute to marker on timeline item</p> Attribute <p>timeline_item (resolve.TimelineItem): resolve's object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_publish_attribute(timeline_item, value):\n    \"\"\" Set Publish attribute to marker on timeline item\n\n    Attribute:\n        timeline_item (resolve.TimelineItem): resolve's object\n    \"\"\"\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n    tag_data[\"publish\"] = value\n    # set data to the publish attribute\n    set_timeline_item_ayon_tag(timeline_item, tag_data)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.set_timeline_item_ayon_tag","title":"<code>set_timeline_item_ayon_tag(timeline_item, data=None)</code>","text":"<p>Set ayon track item tag to input timeline_item.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TimelineItem</code> <p>resolve api object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>json loaded data</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_timeline_item_ayon_tag(timeline_item, data=None):\n    \"\"\"\n    Set ayon track item tag to input timeline_item.\n\n    Attributes:\n        trackItem (resolve.TimelineItem): resolve api object\n\n    Returns:\n        dict: json loaded data\n    \"\"\"\n    data = data or {}\n\n    # get available ayon tag if any\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n\n    if constants.AYON_MARKER_WORKFLOW:\n        # delete tag as it is not updatable\n        if tag_data:\n            delete_ayon_marker(timeline_item)\n\n        tag_data.update(data)\n        set_ayon_marker(timeline_item, tag_data)\n    else:\n        if tag_data:\n            media_pool_item = timeline_item.GetMediaPoolItem()\n            # it not tag then create one\n            tag_data.update(data)\n            media_pool_item.SetMetadata(\n                constants.AYON_TAG_NAME, json.dumps(tag_data))\n        else:\n            tag_data = data\n            # if ayon tag available then update with input data\n            # add it to the input track item\n            timeline_item.SetMetadata(\n                constants.AYON_TAG_NAME, json.dumps(tag_data))\n\n    return tag_data\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.swap_clips","title":"<code>swap_clips(from_clip, to_clip, to_in_frame, to_out_frame)</code>","text":"<p>Swapping clips on timeline in timelineItem</p> <p>It will add take and activate it to the frame range which is inputted</p> <p>Parameters:</p> Name Type Description Default <code>to_clip_name</code> <code>str</code> <p>name of to_clip</p> required <code>to_in_frame</code> <code>float</code> <p>cut in frame, usually <code>GetLeftOffset()</code></p> required <code>to_out_frame</code> <code>float</code> <p>cut out frame, usually left offset plus duration</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if successfully replaced</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def swap_clips(from_clip, to_clip, to_in_frame, to_out_frame):\n    \"\"\"\n    Swapping clips on timeline in timelineItem\n\n    It will add take and activate it to the frame range which is inputted\n\n    Args:\n        from_clip (resolve.TimelineItem)\n        to_clip (resolve.mediaPoolItem)\n        to_clip_name (str): name of to_clip\n        to_in_frame (float): cut in frame, usually `GetLeftOffset()`\n        to_out_frame (float): cut out frame, usually left offset plus duration\n\n    Returns:\n        bool: True if successfully replaced\n\n    \"\"\"\n    # copy ACES input transform from timeline clip to new media item\n    mediapool_item_from_timeline = from_clip.GetMediaPoolItem()\n    _idt = mediapool_item_from_timeline.GetClipProperty('IDT')\n    to_clip.SetClipProperty('IDT', _idt)\n\n    _clip_prop = to_clip.GetClipProperty\n    to_clip_name = _clip_prop(\"File Name\")\n    # add clip item as take to timeline\n    take = from_clip.AddTake(\n        to_clip,\n        float(to_in_frame),\n        float(to_out_frame)\n    )\n\n    if not take:\n        return False\n\n    for take_index in range(1, (int(from_clip.GetTakesCount()) + 1)):\n        take_item = from_clip.GetTakeByIndex(take_index)\n        take_mp_item = take_item[\"mediaPoolItem\"]\n        if to_clip_name in take_mp_item.GetName():\n            from_clip.SelectTakeByIndex(take_index)\n            from_clip.FinalizeTake()\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/index.html#client.ayon_resolve.api.update_container","title":"<code>update_container(timeline_item, data=None)</code>","text":"<p>Update container data to input timeline_item's ayon marker data.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>A containerized track item.</p> required <code>data</code> <code>dict)[optional]</code> <p>dictionary with data to be updated</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if container was updated correctly</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def update_container(timeline_item, data=None):\n    \"\"\"Update container data to input timeline_item's ayon marker data.\n\n    Args:\n        timeline_item (resolve.TimelineItem): A containerized track item.\n        data (dict)[optional]: dictionary with data to be updated\n\n    Returns:\n        bool: True if container was updated correctly\n\n    \"\"\"\n    data = data or {}\n\n    container = lib.get_timeline_item_ayon_tag(timeline_item)\n\n    for _key, _value in container.items():\n        try:\n            container[_key] = data[_key]\n        except KeyError:\n            pass\n\n    log.info(\"Updating container: `{}`\".format(timeline_item))\n    return bool(lib.set_timeline_item_ayon_tag(timeline_item, container))\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/action.html","title":"action","text":""},{"location":"autoapi/client/ayon_resolve/api/action.html#client.ayon_resolve.api.action.SelectInvalidAction","title":"<code>SelectInvalidAction</code>","text":"<p>               Bases: <code>Action</code></p> <p>Select invalid clips in Resolve timeline when plug-in failed.</p> <p>To retrieve the invalid nodes this assumes a static <code>get_invalid()</code> method is available on the plugin.</p> Source code in <code>client/ayon_resolve/api/action.py</code> <pre><code>class SelectInvalidAction(pyblish.api.Action):\n    \"\"\"Select invalid clips in Resolve timeline when plug-in failed.\n\n    To retrieve the invalid nodes this assumes a static `get_invalid()`\n    method is available on the plugin.\n\n    \"\"\"\n    label = \"Select invalid\"\n    on = \"failed\"  # This action is only available on a failed plug-in\n    icon = \"search\"  # Icon from Awesome Icon\n\n    def process(self, context, plugin):\n\n        try:\n            from .lib import get_project_manager\n            pm = get_project_manager()\n            self.log.debug(pm)\n        except ImportError:\n            raise ImportError(\"Current host is not Resolve\")\n\n        errored_instances = get_errored_instances_from_context(context,\n                                                               plugin=plugin)\n\n        # Get the invalid nodes for the plug-ins\n        self.log.info(\"Finding invalid clips..\")\n        invalid = list()\n        for instance in errored_instances:\n            invalid_nodes = plugin.get_invalid(instance)\n            if invalid_nodes:\n                if isinstance(invalid_nodes, (list, tuple)):\n                    invalid.extend(invalid_nodes)\n                else:\n                    self.log.warning(\"Plug-in returned to be invalid, \"\n                                     \"but has no selectable nodes.\")\n\n        # Ensure unique (process each node only once)\n        invalid = list(set(invalid))\n\n        if invalid:\n            self.log.info(\"Selecting invalid nodes: %s\" % \", \".join(invalid))\n            # TODO: select resolve timeline track items in current timeline\n        else:\n            self.log.info(\"No invalid nodes found.\")\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/constants.html","title":"constants","text":""},{"location":"autoapi/client/ayon_resolve/api/lib.html","title":"lib","text":""},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.create_bin","title":"<code>create_bin(name, root=None, set_as_current=True)</code>","text":"<p>Create media pool's folder.</p> <p>Return folder object and if the name does not exist it will create a new. If the input name is with forward or backward slashes then it will create all parents and return the last child bin object</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of folder / bin, or hierarchycal name \"parent/name\"</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <code>set_as_current</code> <code>resolve.Folder)[optional]</code> <p>Whether to set the resulting bin as current folder or not.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.Folder</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_bin(name: str,\n               root: object = None,\n               set_as_current: bool = True) -&gt; object:\n    \"\"\"\n    Create media pool's folder.\n\n    Return folder object and if the name does not exist it will create a new.\n    If the input name is with forward or backward slashes then it will create\n    all parents and return the last child bin object\n\n    Args:\n        name (str): name of folder / bin, or hierarchycal name \"parent/name\"\n        root (resolve.Folder)[optional]: root folder / bin object\n        set_as_current (resolve.Folder)[optional]: Whether to set the\n            resulting bin as current folder or not.\n\n    Returns:\n        object: resolve.Folder\n    \"\"\"\n    # get all variables\n    media_pool = get_current_resolve_project().GetMediaPool()\n    root_bin = root or media_pool.GetRootFolder()\n\n    # create hierarchy of bins in case there is slash in name\n    if \"/\" in name.replace(\"\\\\\", \"/\"):\n        child_bin = None\n        for bname in name.split(\"/\"):\n            child_bin = create_bin(bname,\n                                   root=child_bin or root_bin,\n                                   set_as_current=set_as_current)\n        if child_bin:\n            return child_bin\n    else:\n        # Find existing folder or create it\n        for subfolder in root_bin.GetSubFolderList():\n            if subfolder.GetName() == name:\n                created_bin = subfolder\n                break\n        else:\n            created_bin = media_pool.AddSubFolder(root_bin, name)\n\n        if set_as_current:\n            media_pool.SetCurrentFolder(created_bin)\n\n        return created_bin\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.create_compound_clip","title":"<code>create_compound_clip(clip_data, name, folder)</code>","text":"<p>Convert timeline object into nested timeline object</p> <p>Parameters:</p> Name Type Description Default <code>clip_data</code> <code>dict</code> <p>timeline item object packed into dict               with project, timeline (sequence)</p> required <code>folder</code> <code>Folder</code> <p>media pool folder object,</p> required <code>name</code> <code>str</code> <p>name for compound clip</p> required <p>Returns:</p> Type Description <p>resolve.MediaPoolItem: media pool item with compound clip timeline(cct)</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_compound_clip(clip_data, name, folder):\n    \"\"\"\n    Convert timeline object into nested timeline object\n\n    Args:\n        clip_data (dict): timeline item object packed into dict\n                          with project, timeline (sequence)\n        folder (resolve.MediaPool.Folder): media pool folder object,\n        name (str): name for compound clip\n\n    Returns:\n        resolve.MediaPoolItem: media pool item with compound clip timeline(cct)\n    \"\"\"\n    # get basic objects form data\n    resolve_project = clip_data[\"project\"]\n    timeline = clip_data[\"timeline\"]\n    clip = clip_data[\"clip\"]\n\n    # get details of objects\n    clip_item = clip[\"item\"]\n\n    mp = resolve_project.GetMediaPool()\n\n    # get clip attributes\n    clip_attributes = get_clip_attributes(clip_item)\n\n    mp_item = clip_item.GetMediaPoolItem()\n    _mp_props = mp_item.GetClipProperty\n\n    mp_first_frame = int(_mp_props(\"Start\"))\n    mp_last_frame = int(_mp_props(\"End\"))\n\n    # initialize basic source timing for otio\n    ci_l_offset = clip_item.GetLeftOffset()\n    ci_duration = clip_item.GetDuration()\n    rate = float(_mp_props(\"FPS\"))\n\n    # source rational times\n    mp_in_rc = otio.opentime.RationalTime((ci_l_offset), rate)\n    mp_out_rc = otio.opentime.RationalTime((ci_l_offset + ci_duration - 1), rate)\n\n    # get frame in and out for clip swapping\n    in_frame = otio.opentime.to_frames(mp_in_rc)\n    out_frame = otio.opentime.to_frames(mp_out_rc)\n\n    # keep original sequence\n    tl_origin = timeline\n\n    # Set current folder to input media_pool_folder:\n    mp.SetCurrentFolder(folder)\n\n    # check if clip doesn't exist already:\n    clips = folder.GetClipList()\n    cct = next((c for c in clips\n                if c.GetName() in name), None)\n\n    if cct:\n        print(f\"Compound clip exists: {cct}\")\n    else:\n        # Create empty timeline in current folder and give name:\n        cct = mp.CreateEmptyTimeline(name)\n\n        # check if clip doesn't exist already:\n        clips = folder.GetClipList()\n        cct = next((c for c in clips\n                    if c.GetName() in name), None)\n        print(f\"Compound clip created: {cct}\")\n\n        with maintain_current_timeline(cct, tl_origin):\n            # Add input clip to the current timeline:\n            mp.AppendToTimeline([{\n                \"mediaPoolItem\": mp_item,\n                \"startFrame\": mp_first_frame,\n                \"endFrame\": mp_last_frame\n            }])\n\n    # Add collected metadata and attributes to the compound clip:\n    if mp_item.GetMetadata(constants.AYON_TAG_NAME):\n        clip_attributes[constants.AYON_TAG_NAME] = mp_item.GetMetadata(\n            constants.AYON_TAG_NAME)[constants.AYON_TAG_NAME]\n\n    # stringify\n    clip_attributes = json.dumps(clip_attributes)\n\n    # add attributes to metadata\n    for k, v in mp_item.GetMetadata().items():\n        cct.SetMetadata(k, v)\n\n    # add metadata to cct\n    cct.SetMetadata(constants.AYON_TAG_NAME, clip_attributes)\n\n    # reset start timecode of the compound clip\n    cct.SetClipProperty(\"Start TC\", _mp_props(\"Start TC\"))\n\n    # swap clips on timeline\n    swap_clips(clip_item, cct, in_frame, out_frame)\n\n    cct.SetClipColor(\"Pink\")\n    return cct\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.create_media_pool_item","title":"<code>create_media_pool_item(files, root=None)</code>","text":"<p>Create media pool item.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list</code> <p>absolute path to a file</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.MediaPoolItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_media_pool_item(files: list,\n                           root: object = None) -&gt; object:\n    \"\"\" Create media pool item.\n\n    Args:\n        files (list): absolute path to a file\n        root (resolve.Folder)[optional]: root folder / bin object\n\n    Returns:\n        object: resolve.MediaPoolItem\n    \"\"\"\n    # get all variables\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    root_bin = root or media_pool.GetRootFolder()\n\n    # make sure files list is not empty and first available file exists\n    filepath = next((f for f in files if os.path.isfile(f)), None)\n    if not filepath:\n        raise FileNotFoundError(\"No file found in input files list\")\n\n    # try to search in bin if the clip does not exist\n    existing_mpi = get_media_pool_item(filepath, root_bin)\n\n    if existing_mpi:\n        return existing_mpi\n\n    # add media to media-pool\n    media_pool_items = media_pool.ImportMedia(files)\n\n    if not media_pool_items:\n        return False\n\n    # return only first found\n    return media_pool_items.pop()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.create_timeline_item","title":"<code>create_timeline_item(media_pool_item, timeline=None, timeline_in=None, source_start=None, source_end=None)</code>","text":"<p>Add media pool item to current or defined timeline.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>resolve's object</p> required <code>timeline</code> <code>Optional[Timeline]</code> <p>resolve's object</p> <code>None</code> <code>timeline_in</code> <code>Optional[int]</code> <p>timeline input frame (sequence frame)</p> <code>None</code> <code>source_start</code> <code>Optional[int]</code> <p>media source input frame (sequence frame)</p> <code>None</code> <code>source_end</code> <code>Optional[int]</code> <p>media source output frame (sequence frame)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def create_timeline_item(\n        media_pool_item: object,\n        timeline: object = None,\n        timeline_in: int = None,\n        source_start: int = None,\n        source_end: int = None,\n) -&gt; object:\n    \"\"\"\n    Add media pool item to current or defined timeline.\n\n    Args:\n        media_pool_item (resolve.MediaPoolItem): resolve's object\n        timeline (Optional[resolve.Timeline]): resolve's object\n        timeline_in (Optional[int]): timeline input frame (sequence frame)\n        source_start (Optional[int]): media source input frame (sequence frame)\n        source_end (Optional[int]): media source output frame (sequence frame)\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    # get all variables\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    clip_name = media_pool_item.GetClipProperty(\"File Name\")\n    timeline = timeline or get_current_timeline()\n\n    # timing variables\n    if all([\n        timeline_in is not None,\n        source_start is not None,\n        source_end is not None\n    ]):\n        fps = timeline.GetSetting(\"timelineFrameRate\")\n        duration = source_end - source_start\n        timecode_in = frames_to_timecode(timeline_in, fps)\n        timecode_out = frames_to_timecode(timeline_in + duration, fps)\n    else:\n        timecode_in = None\n        timecode_out = None\n\n    # if timeline was used then switch it to current timeline\n    with maintain_current_timeline(timeline):\n        # Add input mediaPoolItem to clip data\n        clip_data = {\n            \"mediaPoolItem\": media_pool_item,\n        }\n\n        if source_start:\n            clip_data[\"startFrame\"] = source_start\n        if source_end:\n            clip_data[\"endFrame\"] = source_end\n        if timecode_in:\n            # Note: specifying a recordFrame will fail to place the timeline\n            #  item if there's already an existing clip at that time on the\n            #  active track.\n            clip_data[\"recordFrame\"] = timeline_in\n\n        # add to timeline\n        output_timeline_item = media_pool.AppendToTimeline([clip_data])[0]\n\n        # Adding the item may fail whilst Resolve will still return a\n        # TimelineItem instance - however all `Get*` calls return None\n        # Hence, we check whether the result is valid\n        if output_timeline_item.GetDuration() is None:\n            output_timeline_item = None\n\n    assert output_timeline_item, AssertionError((\n        \"Clip name '{}' wasn't created on the timeline: '{}' \\n\\n\"\n        \"Please check if correct track position is activated, \\n\"\n        \"or if a clip is not already at the timeline in \\n\"\n        \"position: '{}' out: '{}'. \\n\\n\"\n        \"Clip data: {}\"\n    ).format(\n        clip_name, timeline.GetName(), timecode_in, timecode_out, clip_data\n    ))\n    return output_timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.export_timeline_otio","title":"<code>export_timeline_otio(timeline)</code>","text":"<p>Export timeline as otio.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>resolve's timeline</p> required <p>Returns:</p> Name Type Description <code>otio_timeline</code> <code>Timeline</code> <p>Otio timeline.</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def export_timeline_otio(timeline):\n    \"\"\" Export timeline as otio.\n\n    Args:\n        timeline (resolve.Timeline): resolve's timeline\n\n    Returns:\n        otio_timeline (otio.Timeline): Otio timeline.\n    \"\"\"\n    # DaVinci Resolve &lt;= 18.5\n    # Legacy export (slower) through AYON.\n    if not hasattr(timeline, \"Export\"):\n        return otio_export.create_otio_timeline(\n            get_current_resolve_project(),\n            timeline=timeline\n        )\n\n    # DaVinci Resolve &gt;= 18.5\n    # Force export through a temporary file (native)\n    temp_otio_file = _get_otio_temp_file(timeline=timeline)\n    export_timeline_otio_to_file(timeline, temp_otio_file)\n    otio_timeline = otio.adapters.read_from_file(temp_otio_file)\n\n    return otio_timeline\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.export_timeline_otio_native","title":"<code>export_timeline_otio_native(timeline, filepath)</code>","text":"<p>Get timeline otio filepath.</p> <p>Only supported from Resolve 19.5</p> Example <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>resolve's object</p> required <code>filepath</code> <code>str</code> <p>otio file path</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if success</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def export_timeline_otio_native(timeline, filepath):\n    \"\"\"Get timeline otio filepath.\n\n    Only supported from Resolve 19.5\n\n    Example:\n        # Native otio export is available from Resolve 18.5\n        # [major, minor, patch, build, suffix]\n        resolve_version = bmdvr.GetVersion()\n        if resolve_version[0] &lt; 18 or resolve_version[1] &lt; 5:\n            # if it is lower then use ayon's otio exporter\n            otio_timeline = davinci_export.create_otio_timeline(\n                resolve_project, timeline=timeline)\n            davinci_export.write_to_file(otio_timeline, filepath)\n        else:\n            # use native otio export\n            export_timeline_otio_native(timeline, filepath)\n\n    Args:\n        timeline (resolve.Timeline): resolve's object\n        filepath (str): otio file path\n\n    Returns:\n        bool: True if success\n    \"\"\"\n    from . import bmdvr\n\n    try:\n        timeline.Export(filepath, bmdvr.EXPORT_OTIO)\n    except Exception as e:\n        log.error(f\"Failed to export timeline otio: {e}\")\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.export_timeline_otio_native--native-otio-export-is-available-from-resolve-185","title":"Native otio export is available from Resolve 18.5","text":""},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.export_timeline_otio_native--major-minor-patch-build-suffix","title":"[major, minor, patch, build, suffix]","text":"<p>resolve_version = bmdvr.GetVersion() if resolve_version[0] &lt; 18 or resolve_version[1] &lt; 5:     # if it is lower then use ayon's otio exporter     otio_timeline = davinci_export.create_otio_timeline(         resolve_project, timeline=timeline)     davinci_export.write_to_file(otio_timeline, filepath) else:     # use native otio export     export_timeline_otio_native(timeline, filepath)</p>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.export_timeline_otio_to_file","title":"<code>export_timeline_otio_to_file(timeline, filepath)</code>","text":"<p>Export timeline as otio filepath.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>resolve's timeline</p> required <code>filepath</code> <code>str</code> <p>otio file path</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>temporary otio filepath</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def export_timeline_otio_to_file(timeline, filepath):\n    \"\"\"Export timeline as otio filepath.\n\n    Args:\n        timeline (resolve.Timeline): resolve's timeline\n        filepath (str): otio file path\n\n    Returns:\n        str: temporary otio filepath\n    \"\"\"\n    try:\n        from . import bmdvr\n\n        if bmdvr.EXPORT_OTIO is None:\n            raise AttributeError(\"Unsupported native Export OTIO\")\n\n        timeline.Export(filepath, bmdvr.EXPORT_OTIO)\n\n    except Exception as error:\n        log.debug(\n            \"Cannot use native OTIO export (%r).\"\n            \"Default to AYON own implementation.\",\n            error\n        )\n        otio_timeline = otio_export.create_otio_timeline(\n            get_current_resolve_project(),\n            timeline=timeline\n        )\n        otio_export.write_to_file(otio_timeline, filepath)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_any_timeline","title":"<code>get_any_timeline()</code>","text":"<p>Get any timeline object.</p> <p>Returns:</p> Type Description <p>object | None: resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_any_timeline():\n    \"\"\"Get any timeline object.\n\n    Returns:\n        object | None: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    timeline_count = resolve_project.GetTimelineCount()\n    if timeline_count &gt; 0:\n        return resolve_project.GetTimelineByIndex(1)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_clip_attributes","title":"<code>get_clip_attributes(clip)</code>","text":"<p>Collect basic attributes from resolve timeline item</p> <p>Parameters:</p> Name Type Description Default <code>clip</code> <code>TimelineItem</code> <p>timeline item object</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>all collected attributres as key: values</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_clip_attributes(clip):\n    \"\"\"\n    Collect basic attributes from resolve timeline item\n\n    Args:\n        clip (resolve.TimelineItem): timeline item object\n\n    Returns:\n        dict: all collected attributres as key: values\n    \"\"\"\n    mp_item = clip.GetMediaPoolItem()\n\n    return {\n        \"clipIn\": clip.GetStart(),\n        \"clipOut\": clip.GetEnd(),\n        \"clipLeftOffset\": clip.GetLeftOffset(),\n        \"clipRightOffset\": clip.GetRightOffset(),\n        \"clipMarkers\": clip.GetMarkers(),\n        \"clipFlags\": clip.GetFlagList(),\n        \"sourceId\": mp_item.GetMediaId(),\n        \"sourceProperties\": mp_item.GetClipProperty()\n    }\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_clip_resolution_from_media_pool","title":"<code>get_clip_resolution_from_media_pool(timeline_item_data)</code>","text":"<p>Return the clip resolution from media pool data.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>Timeline item to investigate.</p> required <p>Returns:</p> Name Type Description <code>resolution_info</code> <code>dict</code> <p>The parsed resolution data.</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_clip_resolution_from_media_pool(timeline_item_data):\n    \"\"\"Return the clip resolution from media pool data.\n\n    Args:\n        timeline_item_data (dict): Timeline item to investigate.\n\n    Returns:\n        resolution_info (dict): The parsed resolution data.\n    \"\"\"\n    clip_item = timeline_item_data[\"clip\"][\"item\"]\n    media_pool_item = clip_item.GetMediaPoolItem()\n    clip_properties = media_pool_item.GetClipProperty()\n\n    try:\n        width, height = clip_properties[\"Resolution\"].split(\"x\")\n    except (KeyError, ValueError):\n        width = height = None\n\n    try:\n        clip_par = clip_properties[\"PAR\"]  # Pixel Aspect Resolution\n        pixel_aspect = constants.PAR_VALUES[clip_par]\n\n    except (KeyError, ValueError):  # Unknown or undetected PAR\n        pixel_aspect = 1.0\n\n    return {\"width\": width, \"height\": height, \"pixelAspect\": pixel_aspect}\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_current_resolve_project","title":"<code>get_current_resolve_project()</code>","text":"<p>Get current resolve project object.</p> <p>Returns:</p> Type Description <p>resolve.Project</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_resolve_project():\n    \"\"\"Get current resolve project object.\n\n    Returns:\n        resolve.Project\n    \"\"\"\n    project_manager = get_project_manager()\n    return project_manager.GetCurrentProject()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_current_timeline","title":"<code>get_current_timeline(new=False)</code>","text":"<p>Get current timeline object.</p> <p>Parameters:</p> Name Type Description Default <code>new</code> <code>bool)[optional]</code> <p>[DEPRECATED] if True it will create new timeline if none exists</p> <code>False</code> <p>Returns:</p> Type Description <p>object | None: resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_timeline(new=False):\n    \"\"\"Get current timeline object.\n\n    Args:\n        new (bool)[optional]: [DEPRECATED] if True it will create\n            new timeline if none exists\n\n    Returns:\n        object | None: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    timeline = resolve_project.GetCurrentTimeline()\n\n    # return current timeline if any\n    if timeline:\n        return timeline\n\n    # TODO: [deprecated] and will be removed in future\n    if new:\n        return get_new_timeline()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_current_timeline_items","title":"<code>get_current_timeline_items(filter=False, track_type=None, track_name=None, selecting_color=None)</code>","text":"<p>Get all available current timeline track items</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_current_timeline_items(\n        filter: bool = False,\n        track_type: str = None,\n        track_name: str = None,\n        selecting_color: str = None) -&gt; List[Dict[str, Any]]:\n    \"\"\"Get all available current timeline track items\"\"\"\n    track_type = track_type or \"video\"\n    selecting_color = selecting_color or constants.SELECTED_CLIP_COLOR\n    resolve_project = get_current_resolve_project()\n\n    # get timeline anyhow\n    timeline = get_current_timeline() or get_any_timeline()\n    if not timeline:\n        return []\n\n    selected_clips = []\n\n    # get all tracks count filtered by track type\n    selected_track_count = timeline.GetTrackCount(track_type)\n\n    # loop all tracks and get items\n    _clips = {}\n    for track_index in range(1, (int(selected_track_count) + 1)):\n        _track_name = timeline.GetTrackName(track_type, track_index)\n\n        # filter out all unmatched track names\n        if track_name and _track_name not in track_name:\n            continue\n\n        timeline_items = timeline.GetItemListInTrack(track_type, track_index)\n        _clips[track_index] = timeline_items\n\n        _data = {\n            \"project\": resolve_project,\n            \"timeline\": timeline,\n            \"track\": {\n                \"name\": _track_name,\n                \"index\": track_index,\n                \"type\": track_type}\n        }\n        # get track item object and its color\n        for clip_index, ti in enumerate(_clips[track_index]):\n            data = _data.copy()\n            data[\"clip\"] = {\n                \"item\": ti,\n                \"index\": clip_index\n            }\n            ti_color = ti.GetClipColor()\n            if filter and selecting_color in ti_color or not filter:\n                selected_clips.append(data)\n    return selected_clips\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_media_pool_item","title":"<code>get_media_pool_item(filepath, root=None)</code>","text":"<p>Return clip if found in folder with use of input file path.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>absolute path to a file</p> required <code>root</code> <code>resolve.Folder)[optional]</code> <p>root folder / bin object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.MediaPoolItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_media_pool_item(filepath, root: object = None) -&gt; object:\n    \"\"\"\n    Return clip if found in folder with use of input file path.\n\n    Args:\n        filepath (str): absolute path to a file\n        root (resolve.Folder)[optional]: root folder / bin object\n\n    Returns:\n        object: resolve.MediaPoolItem\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    root = root or media_pool.GetRootFolder()\n    fname = os.path.basename(filepath)\n\n    for _mpi in root.GetClipList():\n        _mpi_name = _mpi.GetClipProperty(\"File Name\")\n        _mpi_name = get_reformated_path(_mpi_name, first=True)\n        if fname in _mpi_name:\n            return _mpi\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_media_storage","title":"<code>get_media_storage()</code>","text":"<p>Get media storage object.</p> <p>Returns:</p> Type Description <p>resolve.MediaStorage</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_media_storage():\n    \"\"\"Get media storage object.\n\n    Returns:\n        resolve.MediaStorage\n    \"\"\"\n    from . import bmdvr, media_storage\n    if not media_storage:\n        media_storage = bmdvr.GetMediaStorage()\n    return media_storage\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_new_timeline","title":"<code>get_new_timeline(timeline_name=None)</code>","text":"<p>Get new timeline object.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_name</code> <code>str</code> <p>New timeline name.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <p>resolve.Timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_new_timeline(timeline_name: str = None):\n    \"\"\"Get new timeline object.\n\n    Arguments:\n        timeline_name (str): New timeline name.\n\n    Returns:\n        object: resolve.Timeline\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    new_timeline = media_pool.CreateEmptyTimeline(\n        timeline_name or constants.AYON_TIMELINE_NAME)\n    resolve_project.SetCurrentTimeline(new_timeline)\n    return new_timeline\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_otio_clip_instance_data","title":"<code>get_otio_clip_instance_data(otio_timeline, timeline_item_data)</code>","text":"<p>Return otio objects for timeline, track and clip</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>timeline_item_data from list returned by                     resolve.get_current_timeline_items()</p> required <code>otio_timeline</code> <code>Timeline</code> <p>otio object</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>otio clip object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_otio_clip_instance_data(otio_timeline, timeline_item_data):\n    \"\"\"\n    Return otio objects for timeline, track and clip\n\n    Args:\n        timeline_item_data (dict): timeline_item_data from list returned by\n                                resolve.get_current_timeline_items()\n        otio_timeline (otio.schema.Timeline): otio object\n\n    Returns:\n        dict: otio clip object\n\n    \"\"\"\n\n    timeline_item = timeline_item_data[\"clip\"][\"item\"]\n    track_name = timeline_item_data[\"track\"][\"name\"]\n    timeline_range = create_otio_time_range_from_timeline_item_data(\n        timeline_item_data)\n\n    try:  # opentimelineio &gt;= 0.16.0\n        all_clips = otio_timeline.find_clips()\n    except AttributeError:  # legacy\n        all_clips = otio_timeline.each_clip()\n\n    for otio_clip in all_clips:\n        track_name = otio_clip.parent().name\n        parent_range = otio_clip.range_in_parent()\n        if track_name not in track_name:\n            continue\n        if otio_clip.name not in timeline_item.GetName():\n            continue\n        if is_overlapping_otio_ranges(\n                parent_range, timeline_range, strict=True):\n\n            # add pypedata marker to otio_clip metadata\n            for marker in otio_clip.markers:\n                if constants.AYON_MARKER_NAME in marker.name:\n                    otio_clip.metadata.update(marker.metadata)\n            return {\"otioClip\": otio_clip}\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_project_manager","title":"<code>get_project_manager()</code>","text":"<p>Get project manager object.</p> <p>Returns:</p> Type Description <p>resolve.ProjectManager</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_project_manager():\n    \"\"\"Get project manager object.\n\n    Returns:\n        resolve.ProjectManager\n    \"\"\"\n    from . import bmdvr, project_manager\n    if not project_manager:\n        project_manager = bmdvr.GetProjectManager()\n\n    return project_manager\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_publish_attribute","title":"<code>get_publish_attribute(timeline_item)</code>","text":"<p>Get Publish attribute from marker on timeline item</p> Attribute <p>timeline_item (resolve.TimelineItem): resolve's object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_publish_attribute(timeline_item):\n    \"\"\" Get Publish attribute from marker on timeline item\n\n    Attribute:\n        timeline_item (resolve.TimelineItem): resolve's object\n    \"\"\"\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n    return tag_data[\"publish\"]\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_pype_clip_metadata","title":"<code>get_pype_clip_metadata(clip)</code>","text":"<p>Get AYON metadata created by creator plugin</p> <p>Attributes:</p> Name Type Description <code>clip</code> <code>TimelineItem</code> <p>resolve's object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>hierarchy, orig clip attributes</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_pype_clip_metadata(clip):\n    \"\"\"\n    Get AYON metadata created by creator plugin\n\n    Attributes:\n        clip (resolve.TimelineItem): resolve's object\n\n    Returns:\n        dict: hierarchy, orig clip attributes\n    \"\"\"\n    mp_item = clip.GetMediaPoolItem()\n    metadata = mp_item.GetMetadata()\n\n    return metadata.get(constants.AYON_TAG_NAME)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_reformated_path","title":"<code>get_reformated_path(path, padded=False, first=False)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_reformated_path(path, padded=False, first=False):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    first_frame_pattern = re.compile(r\"\\[(\\d+)\\-\\d+\\]\")\n\n    if \"[\" in path:\n        padding_pattern = r\"(\\d+)(?=-)\"\n        padding = len(re.findall(padding_pattern, path).pop())\n        num_pattern = r\"(\\[\\d+\\-\\d+\\])\"\n        if padded:\n            path = re.sub(num_pattern, f\"%0{padding}d\", path)\n        elif first:\n            first_frame = re.findall(first_frame_pattern, path, flags=0)\n            if len(first_frame) &gt;= 1:\n                first_frame = first_frame[0]\n            path = re.sub(num_pattern, first_frame, path)\n        else:\n            path = re.sub(num_pattern, \"%d\", path)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_timeline_item","title":"<code>get_timeline_item(media_pool_item, timeline=None)</code>","text":"<p>Returns clips related to input mediaPoolItem.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>resolve's object</p> required <code>timeline</code> <code>resolve.Timeline)[optional]</code> <p>resolve's object</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item(media_pool_item: object,\n                      timeline: object = None) -&gt; object:\n    \"\"\"\n    Returns clips related to input mediaPoolItem.\n\n    Args:\n        media_pool_item (resolve.MediaPoolItem): resolve's object\n        timeline (resolve.Timeline)[optional]: resolve's object\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    clip_name = media_pool_item.GetClipProperty(\"File Name\")\n    output_timeline_item = None\n    timeline = timeline or get_current_timeline()\n\n    with maintain_current_timeline(timeline):\n        # search the timeline for the added clip\n\n        for ti_data in get_current_timeline_items():\n            ti_clip_item = ti_data[\"clip\"][\"item\"]\n            ti_media_pool_item = ti_clip_item.GetMediaPoolItem()\n\n            # Skip items that do not have a media pool item, like for example\n            # an \"Adjustment Clip\" or a \"Fusion Composition\" from the effects\n            # toolbox\n            if not ti_media_pool_item:\n                continue\n\n            if clip_name in ti_media_pool_item.GetClipProperty(\"File Name\"):\n                output_timeline_item = ti_clip_item\n\n    return output_timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_timeline_item_ayon_tag","title":"<code>get_timeline_item_ayon_tag(timeline_item)</code>","text":"<p>Get ayon track item tag created by creator or loader plugin.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TimelineItem</code> <p>resolve object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>ayon tag data</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item_ayon_tag(timeline_item):\n    \"\"\"\n    Get ayon track item tag created by creator or loader plugin.\n\n    Attributes:\n        trackItem (resolve.TimelineItem): resolve object\n\n    Returns:\n        dict: ayon tag data\n    \"\"\"\n    return_tag = None\n\n    if constants.AYON_MARKER_WORKFLOW:\n        return_tag = get_ayon_marker(timeline_item)\n    else:\n        media_pool_item = timeline_item.GetMediaPoolItem()\n\n        # get all tags from track item\n        _tags = media_pool_item.GetMetadata()\n        if not _tags:\n            return None\n        for key, data in _tags.items():\n            # return only correct tag defined by global name\n            if key in constants.AYON_TAG_NAME:\n                return_tag = json.loads(data)\n\n    return return_tag\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_timeline_item_by_name","title":"<code>get_timeline_item_by_name(name)</code>","text":"<p>Get timeline item by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>name of timeline item</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>resolve.TimelineItem</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_item_by_name(name: str) -&gt; object:\n    \"\"\"Get timeline item by name.\n\n    Args:\n        name (str): name of timeline item\n\n    Returns:\n        object: resolve.TimelineItem\n    \"\"\"\n    for _ti_data in get_current_timeline_items():\n        _ti_clip = _ti_data[\"clip\"][\"item\"]\n        tag_data = get_timeline_item_pype_tag(_ti_clip)\n        tag_name = tag_data.get(\"namespace\")\n        if not tag_name:\n            continue\n        if tag_name in name:\n            return _ti_clip\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.get_timeline_media_pool_item","title":"<code>get_timeline_media_pool_item(timeline, root=None)</code>","text":"<p>Return MediaPoolItem from Timeline</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>timeline object</p> required <code>root</code> <code>Folder</code> <p>root folder / bin object</p> <code>None</code> <p>Returns:</p> Type Description <code>object</code> <p>resolve.MediaPoolItem: media pool item from timeline</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def get_timeline_media_pool_item(timeline, root=None) -&gt; object:\n    \"\"\"Return MediaPoolItem from Timeline\n\n\n    Args:\n        timeline (resolve.Timeline): timeline object\n        root (resolve.Folder): root folder / bin object\n\n    Returns:\n        resolve.MediaPoolItem: media pool item from timeline\n    \"\"\"\n\n    # Due to limitations in the Resolve API we can't get\n    # the media pool item directly from the timeline.\n    # We can find it by name, however names are not\n    # enforced to be unique across bins. So, we give it\n    # unique name.\n    original_name = timeline.GetName()\n    identifier = str(uuid.uuid4().hex)\n    try:\n        timeline.SetName(identifier)\n        for item in iter_all_media_pool_clips(root=root):\n            if item.GetName() != identifier:\n                continue\n            return item\n    finally:\n        # Revert to original name\n        timeline.SetName(original_name)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.imprint","title":"<code>imprint(timeline_item, data=None)</code>","text":"<p>Adding <code>Ayon data</code> into a timeline item track item tag.</p> <p>Also including publish attribute into tag.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>resolve's object</p> required <code>data</code> <code>dict</code> <p>Any data which needs to be imprinted</p> <code>None</code> <p>Examples:</p> <p>data = {     'asset': 'sq020sh0280',     'family': 'render',     'subset': 'subsetMain' }</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def imprint(timeline_item, data=None):\n    \"\"\"\n    Adding `Ayon data` into a timeline item track item tag.\n\n    Also including publish attribute into tag.\n\n    Arguments:\n        timeline_item (resolve.TimelineItem): resolve's object\n        data (dict): Any data which needs to be imprinted\n\n    Examples:\n        data = {\n            'asset': 'sq020sh0280',\n            'family': 'render',\n            'subset': 'subsetMain'\n        }\n    \"\"\"\n    data = data or {}\n\n    set_timeline_item_ayon_tag(timeline_item, data)\n\n    # add publish attribute\n    set_publish_attribute(timeline_item, True)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.iter_all_media_pool_clips","title":"<code>iter_all_media_pool_clips(root=None)</code>","text":"<p>Recursively iterate all media pool clips in current project</p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Optional[Folder]</code> <p>root folder / bin object. When None, defaults to media pool root folder.</p> <code>None</code> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def iter_all_media_pool_clips(root=None):\n    \"\"\"Recursively iterate all media pool clips in current project\n\n    Args:\n        root (Optional[resolve.Folder]): root folder / bin object.\n            When None, defaults to media pool root folder.\n    \"\"\"\n    root = root or get_current_project().GetMediaPool().GetRootFolder()\n    queue = [root]\n    for folder in queue:\n        for clip in folder.GetClipList():\n            yield clip\n        queue.extend(folder.GetSubFolderList())\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.maintain_current_timeline","title":"<code>maintain_current_timeline(to_timeline, from_timeline=None)</code>","text":"<p>Maintain current timeline selection during context</p> <p>Attributes:</p> Name Type Description <code>from_timeline</code> <code>resolve.Timeline)[optional]</code> <p>Example:     &gt;&gt;&gt; print(from_timeline.GetName())     timeline1     &gt;&gt;&gt; print(to_timeline.GetName())     timeline2</p> <pre><code>&gt;&gt;&gt; with maintain_current_timeline(to_timeline):\n...     print(get_current_timeline().GetName())\ntimeline2\n\n&gt;&gt;&gt; print(get_current_timeline().GetName())\ntimeline1\n</code></pre> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintain_current_timeline(to_timeline: object,\n                              from_timeline: object = None):\n    \"\"\"Maintain current timeline selection during context\n\n    Attributes:\n        from_timeline (resolve.Timeline)[optional]:\n    Example:\n        &gt;&gt;&gt; print(from_timeline.GetName())\n        timeline1\n        &gt;&gt;&gt; print(to_timeline.GetName())\n        timeline2\n\n        &gt;&gt;&gt; with maintain_current_timeline(to_timeline):\n        ...     print(get_current_timeline().GetName())\n        timeline2\n\n        &gt;&gt;&gt; print(get_current_timeline().GetName())\n        timeline1\n    \"\"\"\n    project = get_current_resolve_project()\n    working_timeline = from_timeline or project.GetCurrentTimeline()\n\n    # search timeline withing project timelines in case the\n    # to_timeline is MediaPoolItem\n    # Note: this is a hacky way of identifying if object is timeline since\n    #   mediapool item is not having AddTrack attribute. API is not providing\n    #   any other way to identify the object type. And hasattr is returning\n    #   false info.\n    if \"AddTrack\" not in dir(to_timeline):\n        tcount = project.GetTimelineCount()\n        for idx in range(0, int(tcount)):\n            timeline = project.GetTimelineByIndex(idx + 1)\n            if timeline.GetName() == to_timeline.GetName():\n                to_timeline = timeline\n                break\n\n    try:\n        # switch to the input timeline\n        result = project.SetCurrentTimeline(to_timeline)\n        if not result:\n            raise ValueError(f\"Failed to switch to timeline: {to_timeline}\")\n\n        current_timeline = project.GetCurrentTimeline()\n        yield current_timeline\n    finally:\n        # put the original working timeline to context\n        project.SetCurrentTimeline(working_timeline)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.maintain_page_by_name","title":"<code>maintain_page_by_name(page_name)</code>","text":"<p>Maintain specific page by name.</p> <p>Parameters:</p> Name Type Description Default <code>page_name</code> <code>str</code> <p>name of the page</p> required Example <p>with maintain_page_by_name(\"Deliver\"): ...     print(\"Deliver page is open\") Deliver page is open</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>@contextlib.contextmanager\ndef maintain_page_by_name(page_name):\n    \"\"\"Maintain specific page by name.\n\n    Args:\n        page_name (str): name of the page\n\n    Example:\n        &gt;&gt;&gt; with maintain_page_by_name(\"Deliver\"):\n        ...     print(\"Deliver page is open\")\n        Deliver page is open\n    \"\"\"\n    from . import bmdvr\n    current_page = bmdvr.GetCurrentPage()\n\n    if not bmdvr.OpenPage(page_name):\n        raise ValueError(f\"Could not open page {page_name}\")\n\n    try:\n        yield\n    finally:\n        bmdvr.OpenPage(current_page)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.remove_media_pool_item","title":"<code>remove_media_pool_item(media_pool_item)</code>","text":"<p>Remove media pool item.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>resolve's object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if success</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def remove_media_pool_item(media_pool_item: object) -&gt; bool:\n    \"\"\"Remove media pool item.\n\n    Args:\n        media_pool_item (resolve.MediaPoolItem): resolve's object\n\n    Returns:\n        bool: True if success\n    \"\"\"\n    resolve_project = get_current_resolve_project()\n    media_pool = resolve_project.GetMediaPool()\n    return media_pool.DeleteClips([media_pool_item])\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.set_project_manager_to_folder_name","title":"<code>set_project_manager_to_folder_name(folder_name)</code>","text":"<p>Sets context of Project manager to given folder by name.</p> <p>Searching for folder by given name from root folder to nested. If no existing folder by name it will create one in root folder.</p> <p>Parameters:</p> Name Type Description Default <code>folder_name</code> <code>str</code> <p>name of searched folder</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if success</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Cannot create folder in root</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_project_manager_to_folder_name(folder_name):\n    \"\"\"\n    Sets context of Project manager to given folder by name.\n\n    Searching for folder by given name from root folder to nested.\n    If no existing folder by name it will create one in root folder.\n\n    Args:\n        folder_name (str): name of searched folder\n\n    Returns:\n        bool: True if success\n\n    Raises:\n        Exception: Cannot create folder in root\n\n    \"\"\"\n    # initialize project manager\n    project_manager = get_project_manager()\n\n    set_folder = False\n\n    # go back to root folder\n    if project_manager.GotoRootFolder():\n        log.info(f\"Testing existing folder: {folder_name}\")\n        folders = _convert_resolve_list_type(\n            project_manager.GetFoldersInCurrentFolder())\n        log.info(f\"Testing existing folders: {folders}\")\n        # get me first available folder object\n        # with the same name as in `folder_name` else return False\n        if next((f for f in folders if f in folder_name), False):\n            log.info(f\"Found existing folder: {folder_name}\")\n            set_folder = project_manager.OpenFolder(folder_name)\n\n    if set_folder:\n        return True\n\n    # if folder by name is not existent then create one\n    # go back to root folder\n    log.info(f\"Folder `{folder_name}` not found and will be created\")\n    if project_manager.GotoRootFolder():\n        try:\n            # create folder by given name\n            project_manager.CreateFolder(folder_name)\n            project_manager.OpenFolder(folder_name)\n            return True\n        except NameError as e:\n            log.error((f\"Folder with name `{folder_name}` cannot be created!\"\n                       f\"Error: {e}\"))\n            return False\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.set_publish_attribute","title":"<code>set_publish_attribute(timeline_item, value)</code>","text":"<p>Set Publish attribute to marker on timeline item</p> Attribute <p>timeline_item (resolve.TimelineItem): resolve's object</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_publish_attribute(timeline_item, value):\n    \"\"\" Set Publish attribute to marker on timeline item\n\n    Attribute:\n        timeline_item (resolve.TimelineItem): resolve's object\n    \"\"\"\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n    tag_data[\"publish\"] = value\n    # set data to the publish attribute\n    set_timeline_item_ayon_tag(timeline_item, tag_data)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.set_timeline_item_ayon_tag","title":"<code>set_timeline_item_ayon_tag(timeline_item, data=None)</code>","text":"<p>Set ayon track item tag to input timeline_item.</p> <p>Attributes:</p> Name Type Description <code>trackItem</code> <code>TimelineItem</code> <p>resolve api object</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>json loaded data</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def set_timeline_item_ayon_tag(timeline_item, data=None):\n    \"\"\"\n    Set ayon track item tag to input timeline_item.\n\n    Attributes:\n        trackItem (resolve.TimelineItem): resolve api object\n\n    Returns:\n        dict: json loaded data\n    \"\"\"\n    data = data or {}\n\n    # get available ayon tag if any\n    tag_data = get_timeline_item_ayon_tag(timeline_item)\n\n    if constants.AYON_MARKER_WORKFLOW:\n        # delete tag as it is not updatable\n        if tag_data:\n            delete_ayon_marker(timeline_item)\n\n        tag_data.update(data)\n        set_ayon_marker(timeline_item, tag_data)\n    else:\n        if tag_data:\n            media_pool_item = timeline_item.GetMediaPoolItem()\n            # it not tag then create one\n            tag_data.update(data)\n            media_pool_item.SetMetadata(\n                constants.AYON_TAG_NAME, json.dumps(tag_data))\n        else:\n            tag_data = data\n            # if ayon tag available then update with input data\n            # add it to the input track item\n            timeline_item.SetMetadata(\n                constants.AYON_TAG_NAME, json.dumps(tag_data))\n\n    return tag_data\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/lib.html#client.ayon_resolve.api.lib.swap_clips","title":"<code>swap_clips(from_clip, to_clip, to_in_frame, to_out_frame)</code>","text":"<p>Swapping clips on timeline in timelineItem</p> <p>It will add take and activate it to the frame range which is inputted</p> <p>Parameters:</p> Name Type Description Default <code>to_clip_name</code> <code>str</code> <p>name of to_clip</p> required <code>to_in_frame</code> <code>float</code> <p>cut in frame, usually <code>GetLeftOffset()</code></p> required <code>to_out_frame</code> <code>float</code> <p>cut out frame, usually left offset plus duration</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if successfully replaced</p> Source code in <code>client/ayon_resolve/api/lib.py</code> <pre><code>def swap_clips(from_clip, to_clip, to_in_frame, to_out_frame):\n    \"\"\"\n    Swapping clips on timeline in timelineItem\n\n    It will add take and activate it to the frame range which is inputted\n\n    Args:\n        from_clip (resolve.TimelineItem)\n        to_clip (resolve.mediaPoolItem)\n        to_clip_name (str): name of to_clip\n        to_in_frame (float): cut in frame, usually `GetLeftOffset()`\n        to_out_frame (float): cut out frame, usually left offset plus duration\n\n    Returns:\n        bool: True if successfully replaced\n\n    \"\"\"\n    # copy ACES input transform from timeline clip to new media item\n    mediapool_item_from_timeline = from_clip.GetMediaPoolItem()\n    _idt = mediapool_item_from_timeline.GetClipProperty('IDT')\n    to_clip.SetClipProperty('IDT', _idt)\n\n    _clip_prop = to_clip.GetClipProperty\n    to_clip_name = _clip_prop(\"File Name\")\n    # add clip item as take to timeline\n    take = from_clip.AddTake(\n        to_clip,\n        float(to_in_frame),\n        float(to_out_frame)\n    )\n\n    if not take:\n        return False\n\n    for take_index in range(1, (int(from_clip.GetTakesCount()) + 1)):\n        take_item = from_clip.GetTakeByIndex(take_index)\n        take_mp_item = take_item[\"mediaPoolItem\"]\n        if to_clip_name in take_mp_item.GetName():\n            from_clip.SelectTakeByIndex(take_index)\n            from_clip.FinalizeTake()\n            return True\n    return False\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/menu.html","title":"menu","text":""},{"location":"autoapi/client/ayon_resolve/api/pipeline.html","title":"pipeline","text":"<p>Basic avalon integration</p>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.ResolveHost","title":"<code>ResolveHost</code>","text":"<p>               Bases: <code>HostBase</code>, <code>IWorkfileHost</code>, <code>ILoadHost</code>, <code>IPublishHost</code></p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>class ResolveHost(HostBase, IWorkfileHost, ILoadHost, IPublishHost):\n    name = \"resolve\"\n\n    def install(self):\n        \"\"\"Install resolve-specific functionality of avalon-core.\n\n        This is where you install menus and register families, data\n        and loaders into resolve.\n\n        It is called automatically when installing via `api.install(resolve)`.\n\n        See the Maya equivalent for inspiration on how to implement this.\n\n        \"\"\"\n\n        log.info(\"ayon_resolve installed\")\n\n        pyblish.register_host(self.name)\n        pyblish.register_plugin_path(PUBLISH_PATH)\n        print(\"Registering DaVinci Resolve plug-ins..\")\n\n        register_loader_plugin_path(LOAD_PATH)\n        register_creator_plugin_path(CREATE_PATH)\n        register_inventory_action_path(INVENTORY_PATH)\n\n        # register callback for switching publishable\n        pyblish.register_callback(\"instanceToggled\",\n                                  on_pyblish_instance_toggled)\n\n        get_resolve_module()\n\n    def open_workfile(self, filepath):\n        return open_file(filepath)\n\n    def save_workfile(self, filepath=None):\n        return save_file(filepath)\n\n    def work_root(self, session):\n        return work_root(session)\n\n    def get_current_workfile(self):\n        return current_file()\n\n    def workfile_has_unsaved_changes(self):\n        return has_unsaved_changes()\n\n    def get_workfile_extensions(self):\n        return file_extensions()\n\n    def get_containers(self):\n        return ls()\n\n    def get_context_data(self):\n        # TODO: implement to support persisting context attributes\n        return {}\n\n    def update_context_data(self, data, changes):\n        # TODO: implement to support persisting context attributes\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.ResolveHost.install","title":"<code>install()</code>","text":"<p>Install resolve-specific functionality of avalon-core.</p> <p>This is where you install menus and register families, data and loaders into resolve.</p> <p>It is called automatically when installing via <code>api.install(resolve)</code>.</p> <p>See the Maya equivalent for inspiration on how to implement this.</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def install(self):\n    \"\"\"Install resolve-specific functionality of avalon-core.\n\n    This is where you install menus and register families, data\n    and loaders into resolve.\n\n    It is called automatically when installing via `api.install(resolve)`.\n\n    See the Maya equivalent for inspiration on how to implement this.\n\n    \"\"\"\n\n    log.info(\"ayon_resolve installed\")\n\n    pyblish.register_host(self.name)\n    pyblish.register_plugin_path(PUBLISH_PATH)\n    print(\"Registering DaVinci Resolve plug-ins..\")\n\n    register_loader_plugin_path(LOAD_PATH)\n    register_creator_plugin_path(CREATE_PATH)\n    register_inventory_action_path(INVENTORY_PATH)\n\n    # register callback for switching publishable\n    pyblish.register_callback(\"instanceToggled\",\n                              on_pyblish_instance_toggled)\n\n    get_resolve_module()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.containerise","title":"<code>containerise(timeline_item, name, namespace, context, loader=None, data=None)</code>","text":"<p>Bundle Resolve's object into an assembly and imprint it with metadata</p> <p>Containerization enables a tracking of version, author and origin for loaded assets.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>The object to containerise</p> required <code>name</code> <code>str</code> <p>Name of resulting assembly</p> required <code>namespace</code> <code>str</code> <p>Namespace under which to host container</p> required <code>context</code> <code>dict</code> <p>Asset information</p> required <code>loader</code> <code>str</code> <p>Name of node used to produce this container.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>timeline_item</code> <code>TimelineItem</code> <p>containerized object</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def containerise(timeline_item,\n                 name,\n                 namespace,\n                 context,\n                 loader=None,\n                 data=None):\n    \"\"\"Bundle Resolve's object into an assembly and imprint it with metadata\n\n    Containerization enables a tracking of version, author and origin\n    for loaded assets.\n\n    Arguments:\n        timeline_item (resolve.TimelineItem): The object to containerise\n        name (str): Name of resulting assembly\n        namespace (str): Namespace under which to host container\n        context (dict): Asset information\n        loader (str, optional): Name of node used to produce this container.\n\n    Returns:\n        timeline_item (resolve.TimelineItem): containerized object\n\n    \"\"\"\n\n    data_imprint = OrderedDict({\n        \"schema\": \"openpype:container-2.0\",\n        \"id\": AVALON_CONTAINER_ID,\n        \"name\": str(name),\n        \"namespace\": str(namespace),\n        \"loader\": str(loader),\n        \"representation\": context[\"representation\"][\"id\"],\n    })\n\n    if data:\n        data_imprint.update(data)\n\n    lib.set_timeline_item_ayon_tag(timeline_item, data_imprint)\n\n    return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.ls","title":"<code>ls()</code>","text":"<p>List available containers.</p> <p>This function is used by the Container Manager in Nuke. You'll need to implement a for-loop that then yields one Container at a time.</p> <p>See the <code>container.json</code> schema for details on how it should look, and the Maya equivalent, which is in <code>avalon.maya.pipeline</code></p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def ls():\n    \"\"\"List available containers.\n\n    This function is used by the Container Manager in Nuke. You'll\n    need to implement a for-loop that then *yields* one Container at\n    a time.\n\n    See the `container.json` schema for details on how it should look,\n    and the Maya equivalent, which is in `avalon.maya.pipeline`\n    \"\"\"\n\n    # Media Pool instances from Load Media loader\n    for clip in lib.iter_all_media_pool_clips():\n        data = clip.GetMetadata(constants.AYON_TAG_NAME)\n        if not data:\n            continue\n\n        try:\n            data = json.loads(data)\n        except json.JSONDecodeError:\n            log.warning(\n                f\"Failed to parse json data from media pool item: \"\n                f\"{clip.GetName()}\"\n            )\n            continue\n\n        # treat data as container\n        # There might be cases where clip's metadata are having additional\n        # because it needs to store 'load' and 'publish' data. In that case\n        # we need to get only 'load' data\n        if data.get(\"load\"):\n            data = data[\"load\"]\n\n        # If not all required data, skip it\n        required = ['schema', 'id', 'loader', 'representation']\n        if not all(key in data for key in required):\n            continue\n\n        container = {key: data[key] for key in required}\n        container[\"objectName\"] = clip.GetName()  # Get path in folders\n        container[\"namespace\"] = clip.GetName()\n        container[\"name\"] = clip.GetUniqueId()\n        container[\"_item\"] = clip\n        yield container\n\n    # Timeline instances from Load Clip loader\n    # get all track items from current timeline\n    all_timeline_items = lib.get_current_timeline_items(filter=False)\n\n    for timeline_item_data in all_timeline_items:\n        timeline_item = timeline_item_data[\"clip\"][\"item\"]\n        container = parse_container(timeline_item)\n        if container:\n            yield container\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.maintained_selection","title":"<code>maintained_selection()</code>","text":"<p>Maintain selection during context</p> Example <p>with maintained_selection(): ...     node['selected'].setValue(True) print(node['selected'].value()) False</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>@contextlib.contextmanager\ndef maintained_selection():\n    \"\"\"Maintain selection during context\n\n    Example:\n        &gt;&gt;&gt; with maintained_selection():\n        ...     node['selected'].setValue(True)\n        &gt;&gt;&gt; print(node['selected'].value())\n        False\n    \"\"\"\n    try:\n        # do the operation\n        yield\n    finally:\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.on_pyblish_instance_toggled","title":"<code>on_pyblish_instance_toggled(instance, old_value, new_value)</code>","text":"<p>Toggle node passthrough states on instance toggles.</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def on_pyblish_instance_toggled(instance, old_value, new_value):\n    \"\"\"Toggle node passthrough states on instance toggles.\"\"\"\n\n    log.info(\"instance toggle: {}, old_value: {}, new_value:{} \".format(\n        instance, old_value, new_value))\n\n    from ayon_resolve.api import set_publish_attribute\n\n    # Whether instances should be passthrough based on new value\n    timeline_item = instance.data[\"item\"]\n    set_publish_attribute(timeline_item, new_value)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.parse_container","title":"<code>parse_container(timeline_item, validate=True)</code>","text":"<p>Return container data from timeline_item's marker data.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>A containerized track item.</p> required <code>validate</code> <code>bool)[optional]</code> <p>validating with avalon scheme</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The container schema data for input containerized track item.</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def parse_container(timeline_item, validate=True):\n    \"\"\"Return container data from timeline_item's marker data.\n\n    Args:\n        timeline_item (resolve.TimelineItem): A containerized track item.\n        validate (bool)[optional]: validating with avalon scheme\n\n    Returns:\n        dict: The container schema data for input containerized track item.\n\n    \"\"\"\n    # convert tag metadata to normal keys names\n    data = lib.get_timeline_item_ayon_tag(timeline_item)\n\n    if validate and data and data.get(\"schema\"):\n        schema.validate(data)\n\n    if not isinstance(data, dict):\n        return\n\n    # If not all required data return the empty container\n    required = ['schema', 'id', 'name',\n                'namespace', 'loader', 'representation']\n\n    if not all(key in data for key in required):\n        return\n\n    container = {key: data[key] for key in required}\n\n    container[\"objectName\"] = timeline_item.GetName()\n\n    # Store reference to the node object\n    container[\"_timeline_item\"] = timeline_item\n\n    return container\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.reset_selection","title":"<code>reset_selection()</code>","text":"<p>Deselect all selected nodes</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def reset_selection():\n    \"\"\"Deselect all selected nodes\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/pipeline.html#client.ayon_resolve.api.pipeline.update_container","title":"<code>update_container(timeline_item, data=None)</code>","text":"<p>Update container data to input timeline_item's ayon marker data.</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TimelineItem</code> <p>A containerized track item.</p> required <code>data</code> <code>dict)[optional]</code> <p>dictionary with data to be updated</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if container was updated correctly</p> Source code in <code>client/ayon_resolve/api/pipeline.py</code> <pre><code>def update_container(timeline_item, data=None):\n    \"\"\"Update container data to input timeline_item's ayon marker data.\n\n    Args:\n        timeline_item (resolve.TimelineItem): A containerized track item.\n        data (dict)[optional]: dictionary with data to be updated\n\n    Returns:\n        bool: True if container was updated correctly\n\n    \"\"\"\n    data = data or {}\n\n    container = lib.get_timeline_item_ayon_tag(timeline_item)\n\n    for _key, _value in container.items():\n        try:\n            container[_key] = data[_key]\n        except KeyError:\n            pass\n\n    log.info(\"Updating container: `{}`\".format(timeline_item))\n    return bool(lib.set_timeline_item_ayon_tag(timeline_item, container))\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html","title":"plugin","text":""},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.ClipLoader","title":"<code>ClipLoader</code>","text":"Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class ClipLoader:\n\n    active_bin = None\n    data = {}\n\n    def __init__(self, loader_obj, context, **options):\n        \"\"\" Initialize object\n\n        Arguments:\n            loader_obj (ayon_core.pipeline.load.LoaderPlugin): plugin object\n            context (dict): loader plugin context\n            options (dict)[optional]: possible keys:\n                projectBinPath: \"path/to/binItem\"\n\n        \"\"\"\n        self.__dict__.update(loader_obj.__dict__)\n        self.context = context\n        self.active_project = lib.get_current_project()\n\n        # try to get value from options or evaluate key value for `handles`\n        self.with_handles = options.get(\"handles\") is True\n\n        # try to get value from options or evaluate key value for `load_to`\n        self.new_timeline = (\n            options.get(\"newTimeline\") or\n            options.get(\"load_to\") == \"New timeline\"\n        )\n        # try to get value from options or evaluate key value for `load_how`\n        self.sequential_load = (\n            options.get(\"sequentially\") or\n            options.get(\"load_how\") == \"Sequentially in order\"\n        )\n\n        assert self._populate_data(), str(\n            \"Cannot Load selected data, look into database \"\n            \"or call your supervisor\")\n\n        # inject asset data to representation dict\n        self._get_folder_attributes()\n\n        # add active components to class\n        if self.new_timeline:\n            loader_cls = loader_obj.__class__\n            if loader_cls.timeline:\n                # if multiselection is set then use options sequence\n                self.active_timeline = loader_cls.timeline\n            else:\n                # create new sequence\n                self.active_timeline = lib.get_new_timeline(\n                    \"{}_{}\".format(\n                        self.data[\"timeline_basename\"],\n                        str(uuid.uuid4())[:8]\n                    )\n                )\n                loader_cls.timeline = self.active_timeline\n\n        else:\n            self.active_timeline = (\n                    lib.get_current_timeline() or lib.get_new_timeline()\n            )\n\n    def _populate_data(self):\n        \"\"\" Gets context and convert it to self.data\n        data structure:\n            {\n                \"name\": \"assetName_productName_representationName\"\n                \"binPath\": \"projectBinPath\",\n            }\n        \"\"\"\n        # create name\n        folder_entity = self.context[\"folder\"]\n        product_name = self.context[\"product\"][\"name\"]\n        repre_entity = self.context[\"representation\"]\n\n        folder_name = folder_entity[\"name\"]\n        folder_path = folder_entity[\"path\"]\n        representation_name = repre_entity[\"name\"]\n\n        self.data[\"clip_name\"] = \"_\".join([\n            folder_name,\n            product_name,\n            representation_name\n        ])\n        self.data[\"versionAttributes\"] = self.context[\"version\"][\"attrib\"]\n\n        self.data[\"timeline_basename\"] = \"timeline_{}_{}\".format(\n            product_name, representation_name)\n\n        # solve project bin structure path\n        hierarchy = \"Loader{}\".format(folder_path)\n\n        self.data[\"binPath\"] = hierarchy\n\n        return True\n\n    def _get_folder_attributes(self):\n        \"\"\" Get all available asset data\n\n        joint `data` key with asset.data dict into the representation\n\n        \"\"\"\n\n        self.data[\"folderAttributes\"] = copy.deepcopy(\n            self.context[\"folder\"][\"attrib\"]\n        )\n\n    def load(self, files):\n        \"\"\"Load clip into timeline\n\n        Arguments:\n            files (list[str]): list of files to load into timeline\n        \"\"\"\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create clip media\n        media_pool_item = lib.create_media_pool_item(\n            files,\n            self.active_bin\n        )\n        _clip_property = media_pool_item.GetClipProperty\n        source_in = int(_clip_property(\"Start\"))\n        source_out = int(_clip_property(\"End\"))\n        source_duration = int(_clip_property(\"Frames\"))\n\n        # Trim clip start if slate is present\n        if \"slate\" in self.data[\"versionAttributes\"][\"families\"]:\n            source_in += 1\n            source_duration = source_out - source_in + 1\n\n        if not self.with_handles:\n            # Load file without the handles of the source media\n            # We remove the handles from the source in and source out\n            # so that the handles are excluded in the timeline\n\n            # get version data frame data from db\n            version_attributes = self.data[\"versionAttributes\"]\n            frame_start = version_attributes.get(\"frameStart\")\n            frame_end = version_attributes.get(\"frameEnd\")\n\n            # The version data usually stored the frame range + handles of the\n            # media however certain representations may be shorter because they\n            # exclude those handles intentionally. Unfortunately the\n            # representation does not store that in the database currently;\n            # so we should compensate for those cases. If the media is shorter\n            # than the frame range specified in the database we assume it is\n            # without handles and thus we do not need to remove the handles\n            # from source and out\n            if frame_start is not None and frame_end is not None:\n                # Version has frame range data, so we can compare media length\n                handle_start = version_attributes.get(\"handleStart\", 0)\n                handle_end = version_attributes.get(\"handleEnd\", 0)\n                frame_start_handle = frame_start - handle_start\n                frame_end_handle = frame_end + handle_end\n                database_frame_duration = int(\n                    frame_end_handle - frame_start_handle + 1\n                )\n                if source_duration &gt;= database_frame_duration:\n                    source_in += handle_start\n                    source_out -= handle_end\n\n        # get timeline in\n        timeline_start = self.active_timeline.GetStartFrame()\n        if self.sequential_load:\n            # set timeline start frame\n            timeline_in = int(timeline_start)\n        else:\n            # set timeline start frame + original clip in frame\n            timeline_in = int(\n                timeline_start + self.data[\"folderAttributes\"][\"clipIn\"])\n\n        # make track item from source in bin as item\n        timeline_item = lib.create_timeline_item(\n            media_pool_item,\n            self.active_timeline,\n            timeline_in,\n            source_in,\n            source_out,\n        )\n\n        print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return timeline_item\n\n    def update(self, timeline_item, files):\n        # create project bin for the media to be imported into\n        self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n        # create mediaItem in active project bin\n        # create clip media\n        media_pool_item = lib.create_media_pool_item(\n            files,\n            self.active_bin\n        )\n        _clip_property = media_pool_item.GetClipProperty\n\n        # Read trimming from timeline item\n        timeline_item_in = timeline_item.GetLeftOffset()\n        timeline_item_len = timeline_item.GetDuration()\n        timeline_item_out = timeline_item_in + timeline_item_len\n\n        lib.swap_clips(\n            timeline_item,\n            media_pool_item,\n            timeline_item_in,\n            timeline_item_out\n        )\n\n        print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n        return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.ClipLoader.__init__","title":"<code>__init__(loader_obj, context, **options)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>loader_obj</code> <code>LoaderPlugin</code> <p>plugin object</p> required <code>context</code> <code>dict</code> <p>loader plugin context</p> required <code>options</code> <code>dict)[optional]</code> <p>possible keys: projectBinPath: \"path/to/binItem\"</p> <code>{}</code> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def __init__(self, loader_obj, context, **options):\n    \"\"\" Initialize object\n\n    Arguments:\n        loader_obj (ayon_core.pipeline.load.LoaderPlugin): plugin object\n        context (dict): loader plugin context\n        options (dict)[optional]: possible keys:\n            projectBinPath: \"path/to/binItem\"\n\n    \"\"\"\n    self.__dict__.update(loader_obj.__dict__)\n    self.context = context\n    self.active_project = lib.get_current_project()\n\n    # try to get value from options or evaluate key value for `handles`\n    self.with_handles = options.get(\"handles\") is True\n\n    # try to get value from options or evaluate key value for `load_to`\n    self.new_timeline = (\n        options.get(\"newTimeline\") or\n        options.get(\"load_to\") == \"New timeline\"\n    )\n    # try to get value from options or evaluate key value for `load_how`\n    self.sequential_load = (\n        options.get(\"sequentially\") or\n        options.get(\"load_how\") == \"Sequentially in order\"\n    )\n\n    assert self._populate_data(), str(\n        \"Cannot Load selected data, look into database \"\n        \"or call your supervisor\")\n\n    # inject asset data to representation dict\n    self._get_folder_attributes()\n\n    # add active components to class\n    if self.new_timeline:\n        loader_cls = loader_obj.__class__\n        if loader_cls.timeline:\n            # if multiselection is set then use options sequence\n            self.active_timeline = loader_cls.timeline\n        else:\n            # create new sequence\n            self.active_timeline = lib.get_new_timeline(\n                \"{}_{}\".format(\n                    self.data[\"timeline_basename\"],\n                    str(uuid.uuid4())[:8]\n                )\n            )\n            loader_cls.timeline = self.active_timeline\n\n    else:\n        self.active_timeline = (\n                lib.get_current_timeline() or lib.get_new_timeline()\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.ClipLoader.load","title":"<code>load(files)</code>","text":"<p>Load clip into timeline</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str]</code> <p>list of files to load into timeline</p> required Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def load(self, files):\n    \"\"\"Load clip into timeline\n\n    Arguments:\n        files (list[str]): list of files to load into timeline\n    \"\"\"\n    # create project bin for the media to be imported into\n    self.active_bin = lib.create_bin(self.data[\"binPath\"])\n\n    # create clip media\n    media_pool_item = lib.create_media_pool_item(\n        files,\n        self.active_bin\n    )\n    _clip_property = media_pool_item.GetClipProperty\n    source_in = int(_clip_property(\"Start\"))\n    source_out = int(_clip_property(\"End\"))\n    source_duration = int(_clip_property(\"Frames\"))\n\n    # Trim clip start if slate is present\n    if \"slate\" in self.data[\"versionAttributes\"][\"families\"]:\n        source_in += 1\n        source_duration = source_out - source_in + 1\n\n    if not self.with_handles:\n        # Load file without the handles of the source media\n        # We remove the handles from the source in and source out\n        # so that the handles are excluded in the timeline\n\n        # get version data frame data from db\n        version_attributes = self.data[\"versionAttributes\"]\n        frame_start = version_attributes.get(\"frameStart\")\n        frame_end = version_attributes.get(\"frameEnd\")\n\n        # The version data usually stored the frame range + handles of the\n        # media however certain representations may be shorter because they\n        # exclude those handles intentionally. Unfortunately the\n        # representation does not store that in the database currently;\n        # so we should compensate for those cases. If the media is shorter\n        # than the frame range specified in the database we assume it is\n        # without handles and thus we do not need to remove the handles\n        # from source and out\n        if frame_start is not None and frame_end is not None:\n            # Version has frame range data, so we can compare media length\n            handle_start = version_attributes.get(\"handleStart\", 0)\n            handle_end = version_attributes.get(\"handleEnd\", 0)\n            frame_start_handle = frame_start - handle_start\n            frame_end_handle = frame_end + handle_end\n            database_frame_duration = int(\n                frame_end_handle - frame_start_handle + 1\n            )\n            if source_duration &gt;= database_frame_duration:\n                source_in += handle_start\n                source_out -= handle_end\n\n    # get timeline in\n    timeline_start = self.active_timeline.GetStartFrame()\n    if self.sequential_load:\n        # set timeline start frame\n        timeline_in = int(timeline_start)\n    else:\n        # set timeline start frame + original clip in frame\n        timeline_in = int(\n            timeline_start + self.data[\"folderAttributes\"][\"clipIn\"])\n\n    # make track item from source in bin as item\n    timeline_item = lib.create_timeline_item(\n        media_pool_item,\n        self.active_timeline,\n        timeline_in,\n        source_in,\n        source_out,\n    )\n\n    print(\"Loading clips: `{}`\".format(self.data[\"clip_name\"]))\n    return timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.PublishableClip","title":"<code>PublishableClip</code>","text":"<p>Convert a track item to publishable instance</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item</code> <code>TrackItem</code> <p>hiero track item object</p> required <code>kwargs</code> <code>optional</code> <p>additional data needed for rename=True (presets)</p> required <p>Returns:</p> Type Description <p>hiero.core.TrackItem: hiero track item object with openpype tag</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class PublishableClip:\n    \"\"\"\n    Convert a track item to publishable instance\n\n    Args:\n        timeline_item (hiero.core.TrackItem): hiero track item object\n        kwargs (optional): additional data needed for rename=True (presets)\n\n    Returns:\n        hiero.core.TrackItem: hiero track item object with openpype tag\n    \"\"\"\n    tag_data = {}\n    types = {\n        \"shot\": \"shot\",\n        \"folder\": \"folder\",\n        \"episode\": \"episode\",\n        \"sequence\": \"sequence\",\n        \"track\": \"sequence\",\n    }\n\n    # parents search pattern\n    parents_search_pattern = r\"\\{([a-z]*?)\\}\"\n\n    # default templates for non-ui use\n    rename_default = False\n    hierarchy_default = \"{_folder_}/{_sequence_}/{_track_}\"\n    clip_name_default = \"shot_{_trackIndex_:0&gt;3}_{_clipIndex_:0&gt;4}\"\n    variant_default = \"&lt;track_name&gt;\"\n    review_source_default = None\n    product_type_default = \"plate\"\n    count_from_default = 10\n    count_steps_default = 10\n    vertical_sync_default = False\n    driving_layer_default = \"\"\n\n    # Define which keys of the pre create data should also be 'tag data'\n    tag_keys = {\n        # renameHierarchy\n        \"hierarchy\",\n        # hierarchyData\n        \"folder\", \"episode\", \"sequence\", \"track\", \"shot\",\n        # publish settings\n        \"audio\", \"sourceResolution\",\n        # shot attributes\n        \"workfileFrameStart\", \"handleStart\", \"handleEnd\"\n    }\n\n    def __init__(\n            self,\n            timeline_item_data: dict,\n            vertical_clip_match: dict = None,\n            vertical_clip_used: dict = None,\n            pre_create_data: dict = None,\n            media_pool_folder: str = None,\n            rename_index: int = 0,\n            data: dict = None,\n        ):\n        \"\"\" Initialize object\n\n        Args:\n            timeline_item_data (dict): timeline item data\n            pre_create_data (dict): pre create data\n            media_pool_folder (str): media pool folder\n            rename_index (int): rename index\n            data (dict): additional data\n\n        \"\"\"\n        self.vertical_clip_match = vertical_clip_match \n        self.vertical_clip_used = vertical_clip_used\n\n        self.rename_index = rename_index\n        self.tag_data = data or {}\n\n        # get main parent objects\n        self.timeline_item_data = timeline_item_data\n        self.timeline_item = timeline_item_data[\"clip\"][\"item\"]\n        timeline_name = timeline_item_data[\"timeline\"].GetName()\n        self.timeline_name = str(timeline_name).replace(\" \", \"_\")\n\n        # track item (clip) main attributes\n        self.ti_name = self.timeline_item.GetName()\n        self.ti_index = int(timeline_item_data[\"clip\"][\"index\"])\n\n        # get track name and index\n        track_name = timeline_item_data[\"track\"][\"name\"]\n        self.track_name = str(track_name).replace(\" \", \"_\")  # TODO clarify\n        self.track_index = int(timeline_item_data[\"track\"][\"index\"])\n\n        # adding ui inputs if any\n        self.pre_create_data = pre_create_data or {}\n\n        # adding media pool folder if any\n        self.media_pool_folder = media_pool_folder\n\n        # populate default data before we get other attributes\n        self._populate_timeline_item_default_data()\n\n        # use all populated default data to create all important attributes\n        self._populate_attributes()\n\n        # create parents with correct types\n        self._create_parents()\n\n    def convert(self):\n        \"\"\" Convert track item to publishable instance.\n\n        Returns:\n            timeline_item (resolve.TimelineItem): timeline item with imprinted\n                data in marker\n        \"\"\"\n        # solve track item data and add them to tag data\n        self._convert_to_tag_data()\n\n        # if track name is in review track name and also if driving track name\n        # is not in review track name: skip tag creation\n        if (\n            self.track_name in self.reviewable_source and\n            self.hero_track not in self.reviewable_source\n        ):\n            return\n\n        # deal with clip name\n        new_name = self.tag_data.pop(\"newClipName\")\n\n        if self.rename:\n            self.tag_data[\"asset\"] = new_name\n        else:\n            self.tag_data[\"asset\"] = self.ti_name\n\n        # AYON unique identifier\n        folder_path = \"/{}/{}\".format(\n            self.tag_data[\"hierarchy\"],\n            self.tag_data[\"asset\"],\n        )\n        self.tag_data[\"folderPath\"] = folder_path\n\n        if not constants.AYON_MARKER_WORKFLOW:\n            # create compound clip workflow\n            lib.create_compound_clip(\n                self.timeline_item_data,\n                self.tag_data[\"asset\"],\n                self.media_pool_folder\n            )\n\n            # add timeline_item_data selection to tag\n            self.tag_data.update({\n                \"track_data\": self.timeline_item_data[\"track\"]\n            })\n\n        return self.timeline_item\n\n    def _populate_timeline_item_default_data(self):\n        \"\"\" Populate default formatting data from track item. \"\"\"\n\n        self.timeline_item_default_data = {\n            \"_folder_\": \"shots\",\n            \"_sequence_\": self.timeline_name,\n            \"_track_\": self.track_name,\n            \"_clip_\": self.ti_name,\n            \"_trackIndex_\": self.track_index,\n            \"_clipIndex_\": self.ti_index\n        }\n\n    def _populate_attributes(self):\n        \"\"\" Populate main object attributes. \"\"\"\n        # track item frame range and parent track name for vertical sync check\n        self.clip_in = int(self.timeline_item.GetStart())\n        self.clip_out = int(self.timeline_item.GetEnd())\n\n        # define ui inputs if non gui mode was used\n        self.shot_num = self.ti_index\n\n        # publisher ui attribute inputs or default values if gui was not used\n        def get(key):\n            \"\"\"Shorthand access for code readability\"\"\"\n            return self.pre_create_data.get(key)\n\n        self.rename = get(\"clipRename\") or self.rename_default\n        self.clip_name = get(\"clipName\") or self.clip_name_default\n        self.hierarchy = get(\"hierarchy\") or self.hierarchy_default\n        self.count_from = get(\"countFrom\") or self.count_from_default\n        self.count_steps = get(\"countSteps\") or self.count_steps_default\n        self.variant = get(\"clip_variant\") or self.variant_default\n        self.product_type = get(\"productType\") or self.product_type_default\n        self.vertical_sync = get(\"vSyncOn\") or self.vertical_sync_default\n        self.hero_track = get(\"vSyncTrack\") or self.driving_layer_default\n        self.hero_track = self.hero_track.replace(\" \", \"_\")\n        self.review_source = (\n            get(\"reviewableSource\") or self.review_source_default)\n\n        self.hierarchy_data = {\n            key: get(key) or self.timeline_item_default_data[key]\n            for key in [\"folder\", \"episode\", \"sequence\", \"track\", \"shot\"]\n        }\n\n        # build subset name from layer name\n        if self.variant == \"&lt;track_name&gt;\":\n            self.variant = self.track_name\n\n        # create subset for publishing\n        # TODO: Use creator `get_subset_name` to correctly define name\n        self.product_name = self.product_type + self.variant.capitalize()\n\n    def _replace_hash_to_expression(self, name, text):\n        \"\"\" Replace hash with number in correct padding. \"\"\"\n        _spl = text.split(\"#\")\n        _len = (len(_spl) - 1)\n        _repl = \"{{{0}:0&gt;{1}}}\".format(name, _len)\n        new_text = text.replace((\"#\" * _len), _repl)\n        return new_text\n\n    def _convert_to_tag_data(self):\n        \"\"\"Convert internal data to tag data.\n\n        Populating the tag data into internal variable self.tag_data\n        \"\"\"\n        # define vertical sync attributes\n        hero_track = True\n        self.reviewable_source = \"\"\n\n        if (\n            self.vertical_sync\n            and self.track_name not in self.hero_track\n        ):\n            hero_track = False\n\n        # increasing steps by index of rename iteration\n        self.count_steps *= self.rename_index\n\n        hierarchy_formatting_data = {}\n        _data = self.timeline_item_default_data.copy()\n        if self.pre_create_data:\n\n            # adding tag metadata from ui\n            for _key, _value in self.pre_create_data.items():\n                if _key in self.tag_keys:\n                    self.tag_data[_key] = _value\n\n            # backward compatibility for reviewableSource (2024.12.02)\n            if \"reviewTrack\" in self.pre_create_data:\n                _value = self.tag_data.pop(\"reviewTrack\")\n                self.tag_data[\"reviewableSource\"] = _value\n\n            # driving layer is set as positive match\n            if hero_track or self.vertical_sync:\n                # mark review track\n                if self.review_source and (\n                    self.review_source != self.review_source_default\n                ):\n                    # if review track is defined and not the same as default\n                    self.reviewable_source = self.review_source\n\n                # shot num calculate\n                if self.rename_index == 0:\n                    self.shot_num = self.count_from\n                else:\n                    self.shot_num = self.count_from + self.count_steps\n\n            # clip name sequence number\n            _data.update({\"shot\": self.shot_num})\n\n            # solve # in test to pythonic expression\n            for _key, _value in self.hierarchy_data.items():\n                if \"#\" not in _value:\n                    continue\n                self.hierarchy_data[_key] = self._replace_hash_to_expression(\n                    _key, _value\n                )\n\n            # fill up pythonic expresisons in hierarchy data\n            for _key, _value in self.hierarchy_data.items():\n                hierarchy_formatting_data[_key] = _value.format(**_data)\n        else:\n            # if no gui mode then just pass default data\n            hierarchy_formatting_data = self.hierarchy_data\n\n        tag_instance_data = self._solve_tag_hierarchy_data(\n            hierarchy_formatting_data\n        )\n\n        tag_instance_data.update({\"heroTrack\": True})\n        if hero_track and self.vertical_sync:\n            self.vertical_clip_match.update(\n                {\n                    (self.clip_in, self.clip_out): tag_instance_data\n                }\n            )\n\n        if not hero_track and self.vertical_sync:\n            # driving layer is set as negative match\n            for (hero_in, hero_out), hero_data in self.vertical_clip_match.items():  # noqa\n                \"\"\"Iterate over all clips in vertical sync match\n\n                If clip frame range is outside of hero clip frame range\n                then skip this clip and do not add to hierarchical shared\n                metadata to them.\n                \"\"\"\n                if self.clip_in &lt; hero_in or self.clip_out &gt; hero_out:\n                    continue\n\n                _distrib_data = copy.deepcopy(hero_data)\n                _distrib_data[\"heroTrack\"] = False\n\n                # form used clip unique key\n                data_product_name = hero_data[\"productName\"]\n                new_clip_name = hero_data[\"newClipName\"]\n\n                # get used names list for duplicity check\n                used_names_list = self.vertical_clip_used.setdefault(\n                    f\"{new_clip_name}{data_product_name}\", [])\n\n                clip_product_name = self.product_name\n                variant = self.variant\n\n                # in case track name and product name is the same then add\n                if self.variant == self.track_name:\n                    clip_product_name = self.product_name\n\n                # add track index in case duplicity of names in hero data\n                # INFO: this is for case where hero clip product name\n                #    is the same as current clip product name\n                if clip_product_name in data_product_name:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.track_index}\")\n                    variant = f\"{variant}{self.track_index}\"\n\n                # in case track clip product name had been already used\n                # then add product name with clip index\n                if clip_product_name in used_names_list:\n                    clip_product_name = (\n                        f\"{clip_product_name}{self.rename_index}\")\n                    variant = f\"{variant}{self.rename_index}\"\n\n                _distrib_data[\"productName\"] = clip_product_name\n                _distrib_data[\"variant\"] = variant\n                # assign data to return hierarchy data to tag\n                tag_instance_data = _distrib_data\n\n                # add used product name to used list to avoid duplicity\n                used_names_list.append(clip_product_name)\n                break\n\n        # add data to return data dict\n        self.tag_data.update(tag_instance_data)\n\n        # add uuid to tag data\n        self.tag_data[\"uuid\"] = str(uuid.uuid4())\n\n        # add review track only to hero track\n        if hero_track and self.reviewable_source:\n            self.tag_data[\"reviewTrack\"] = self.reviewable_source\n        else:\n            self.tag_data[\"reviewTrack\"] = None\n\n        # add only review related data if reviewable source is set\n        if self.reviewable_source:\n            review_switch = True\n            reviewable_source = self.reviewable_source\n\n            if self.vertical_sync and not hero_track:\n                review_switch = False\n                reviewable_source = False\n\n            if review_switch:\n                self.tag_data[\"review\"] = True\n            else:\n                self.tag_data.pop(\"review\", None)\n\n            self.tag_data[\"reviewableSource\"] = reviewable_source\n\n\n    def _solve_tag_hierarchy_data(self, hierarchy_formatting_data):\n        \"\"\" Solve tag data from hierarchy data and templates. \"\"\"\n        # fill up clip name and hierarchy keys\n        hierarchy_filled = self.hierarchy.format(**hierarchy_formatting_data)\n        clip_name_filled = self.clip_name.format(**hierarchy_formatting_data)\n\n        return {\n            \"newClipName\": clip_name_filled,\n            \"hierarchy\": hierarchy_filled,\n            \"parents\": self.parents,\n            \"hierarchyData\": hierarchy_formatting_data,\n            \"productName\": self.product_name,\n            \"productType\": self.product_type\n        }\n\n    def _convert_to_entity(self, key):\n        \"\"\" Converting input key to key with type. \"\"\"\n        # convert to entity type\n        folder_type = self.types.get(key)\n\n        assert folder_type, \"Missing folder type for `{}`\".format(\n            key\n        )\n\n        return {\n            \"folder_type\": folder_type,\n            \"entity_name\": self.hierarchy_data[key].format(\n                **self.timeline_item_default_data\n            )\n        }\n\n    def _create_parents(self):\n        \"\"\" Create parents and return it in list. \"\"\"\n        self.parents = []\n\n        pattern = re.compile(self.parents_search_pattern)\n        par_split = [pattern.findall(t).pop()\n                     for t in self.hierarchy.split(\"/\")]\n\n        for key in par_split:\n            parent = self._convert_to_entity(key)\n            self.parents.append(parent)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.PublishableClip.__init__","title":"<code>__init__(timeline_item_data, vertical_clip_match=None, vertical_clip_used=None, pre_create_data=None, media_pool_folder=None, rename_index=0, data=None)</code>","text":"<p>Initialize object</p> <p>Parameters:</p> Name Type Description Default <code>timeline_item_data</code> <code>dict</code> <p>timeline item data</p> required <code>pre_create_data</code> <code>dict</code> <p>pre create data</p> <code>None</code> <code>media_pool_folder</code> <code>str</code> <p>media pool folder</p> <code>None</code> <code>rename_index</code> <code>int</code> <p>rename index</p> <code>0</code> <code>data</code> <code>dict</code> <p>additional data</p> <code>None</code> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def __init__(\n        self,\n        timeline_item_data: dict,\n        vertical_clip_match: dict = None,\n        vertical_clip_used: dict = None,\n        pre_create_data: dict = None,\n        media_pool_folder: str = None,\n        rename_index: int = 0,\n        data: dict = None,\n    ):\n    \"\"\" Initialize object\n\n    Args:\n        timeline_item_data (dict): timeline item data\n        pre_create_data (dict): pre create data\n        media_pool_folder (str): media pool folder\n        rename_index (int): rename index\n        data (dict): additional data\n\n    \"\"\"\n    self.vertical_clip_match = vertical_clip_match \n    self.vertical_clip_used = vertical_clip_used\n\n    self.rename_index = rename_index\n    self.tag_data = data or {}\n\n    # get main parent objects\n    self.timeline_item_data = timeline_item_data\n    self.timeline_item = timeline_item_data[\"clip\"][\"item\"]\n    timeline_name = timeline_item_data[\"timeline\"].GetName()\n    self.timeline_name = str(timeline_name).replace(\" \", \"_\")\n\n    # track item (clip) main attributes\n    self.ti_name = self.timeline_item.GetName()\n    self.ti_index = int(timeline_item_data[\"clip\"][\"index\"])\n\n    # get track name and index\n    track_name = timeline_item_data[\"track\"][\"name\"]\n    self.track_name = str(track_name).replace(\" \", \"_\")  # TODO clarify\n    self.track_index = int(timeline_item_data[\"track\"][\"index\"])\n\n    # adding ui inputs if any\n    self.pre_create_data = pre_create_data or {}\n\n    # adding media pool folder if any\n    self.media_pool_folder = media_pool_folder\n\n    # populate default data before we get other attributes\n    self._populate_timeline_item_default_data()\n\n    # use all populated default data to create all important attributes\n    self._populate_attributes()\n\n    # create parents with correct types\n    self._create_parents()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.PublishableClip.convert","title":"<code>convert()</code>","text":"<p>Convert track item to publishable instance.</p> <p>Returns:</p> Name Type Description <code>timeline_item</code> <code>TimelineItem</code> <p>timeline item with imprinted data in marker</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def convert(self):\n    \"\"\" Convert track item to publishable instance.\n\n    Returns:\n        timeline_item (resolve.TimelineItem): timeline item with imprinted\n            data in marker\n    \"\"\"\n    # solve track item data and add them to tag data\n    self._convert_to_tag_data()\n\n    # if track name is in review track name and also if driving track name\n    # is not in review track name: skip tag creation\n    if (\n        self.track_name in self.reviewable_source and\n        self.hero_track not in self.reviewable_source\n    ):\n        return\n\n    # deal with clip name\n    new_name = self.tag_data.pop(\"newClipName\")\n\n    if self.rename:\n        self.tag_data[\"asset\"] = new_name\n    else:\n        self.tag_data[\"asset\"] = self.ti_name\n\n    # AYON unique identifier\n    folder_path = \"/{}/{}\".format(\n        self.tag_data[\"hierarchy\"],\n        self.tag_data[\"asset\"],\n    )\n    self.tag_data[\"folderPath\"] = folder_path\n\n    if not constants.AYON_MARKER_WORKFLOW:\n        # create compound clip workflow\n        lib.create_compound_clip(\n            self.timeline_item_data,\n            self.tag_data[\"asset\"],\n            self.media_pool_folder\n        )\n\n        # add timeline_item_data selection to tag\n        self.tag_data.update({\n            \"track_data\": self.timeline_item_data[\"track\"]\n        })\n\n    return self.timeline_item\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.ResolveCreator","title":"<code>ResolveCreator</code>","text":"<p>               Bases: <code>Creator</code></p> <p>Resolve Creator class wrapper</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class ResolveCreator(Creator):\n    \"\"\" Resolve Creator class wrapper\"\"\"\n\n    marker_color = \"Purple\"\n    presets = {}\n\n    def apply_settings(self, project_settings):\n        resolve_create_settings = (\n            project_settings.get(\"resolve\", {}).get(\"create\")\n        )\n        self.presets = resolve_create_settings.get(\n            self.__class__.__name__, {}\n        )\n\n    def create(self, subset_name, instance_data, pre_create_data):\n        # adding basic current context resolve objects\n        self.project = lib.get_current_resolve_project()\n        self.timeline = lib.get_current_timeline()\n\n        if pre_create_data.get(\"use_selection\", False):\n            self.selected = lib.get_current_timeline_items(filter=True)\n        else:\n            self.selected = lib.get_current_timeline_items(filter=False)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.TimelineItemLoader","title":"<code>TimelineItemLoader</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>A basic SequenceLoader for Resolve</p> <p>This will implement the basic behavior for a loader to inherit from that will containerize the reference and will implement the <code>remove</code> and <code>update</code> logic.</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>class TimelineItemLoader(LoaderPlugin):\n    \"\"\"A basic SequenceLoader for Resolve\n\n    This will implement the basic behavior for a loader to inherit from that\n    will containerize the reference and will implement the `remove` and\n    `update` logic.\n\n    \"\"\"\n\n    options = [\n        qargparse.Boolean(\n            \"handles\",\n            label=\"Include handles\",\n            default=0,\n            help=\"Load with handles or without?\"\n        ),\n        qargparse.Choice(\n            \"load_to\",\n            label=\"Where to load clips\",\n            items=[\n                \"Current timeline\",\n                \"New timeline\"\n            ],\n            default=0,\n            help=\"Where do you want clips to be loaded?\"\n        ),\n        qargparse.Choice(\n            \"load_how\",\n            label=\"How to load clips\",\n            items=[\n                \"Original timing\",\n                \"Sequentially in order\"\n            ],\n            default=\"Original timing\",\n            help=\"Would you like to place it at original timing?\"\n        )\n    ]\n\n    def load(\n        self,\n        context,\n        name=None,\n        namespace=None,\n        options=None\n    ):\n        pass\n\n    def update(self, container, context):\n        \"\"\"Update an existing `container`\n        \"\"\"\n        pass\n\n    def remove(self, container):\n        \"\"\"Remove an existing `container`\n        \"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.TimelineItemLoader.remove","title":"<code>remove(container)</code>","text":"<p>Remove an existing <code>container</code></p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def remove(self, container):\n    \"\"\"Remove an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.TimelineItemLoader.update","title":"<code>update(container, context)</code>","text":"<p>Update an existing <code>container</code></p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update an existing `container`\n    \"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.get_editorial_publish_data","title":"<code>get_editorial_publish_data(folder_path, product_name, version=None, task=None)</code>","text":"<p>Get editorial publish data from context.</p> <p>Parameters:</p> Name Type Description Default <code>folder_path</code> <code>str</code> <p>Folder path where editorial package is located.</p> required <code>product_name</code> <code>str</code> <p>Editorial product name.</p> required <code>version</code> <code>Optional[str]</code> <p>Editorial product version. Defaults to None.</p> <code>None</code> <code>task</code> <code>Optional[str]</code> <p>Associated task name. Defaults to None (no task).</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>Editorial publish data.</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def get_editorial_publish_data(\n    folder_path,\n    product_name,\n    version=None,\n    task=None,\n) -&gt; dict:\n    \"\"\"Get editorial publish data from context.\n\n    Args:\n        folder_path (str): Folder path where editorial package is located.\n        product_name (str): Editorial product name.\n        version (Optional[str]): Editorial product version. Defaults to None.\n        task (Optional[str]): Associated task name. Defaults to None (no task).\n\n    Returns:\n        dict: Editorial publish data.\n    \"\"\"\n    data = {\n        \"id\": AVALON_INSTANCE_ID,\n        \"family\": \"editorial_pkg\",\n        \"productType\": \"editorial_pkg\",\n        \"productName\": product_name,\n        \"folderPath\": folder_path,\n        \"active\": True,\n        \"publish\": True,\n    }\n\n    if version:\n        data[\"version\"] = version\n\n    if task:\n        data[\"task\"] = task\n\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/plugin.html#client.ayon_resolve.api.plugin.get_representation_files","title":"<code>get_representation_files(project_name, representation)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>project_name</code> <code>str</code> <p>The name of the project.</p> required <code>representation</code> <code>dict</code> <p>The representation to inspect.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>The files associated to the representation.</p> Source code in <code>client/ayon_resolve/api/plugin.py</code> <pre><code>def get_representation_files(project_name, representation):\n    \"\"\"\n    Args:\n        project_name (str): The name of the project.\n        representation (dict): The representation to inspect.\n\n    Returns:\n        list: The files associated to the representation.\n    \"\"\"\n    anatomy = Anatomy(project_name)\n\n    return [\n        anatomy.fill_root(file_data[\"path\"])\n        for file_data in representation[\"files\"]\n    ]\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html","title":"rendering","text":"<p>Rendering API wrapper for Blackmagic Design DaVinci Resolve.</p>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html#client.ayon_resolve.api.rendering.delete_all_processed_jobs","title":"<code>delete_all_processed_jobs()</code>","text":"<p>Delete all processed jobs</p> Source code in <code>client/ayon_resolve/api/rendering.py</code> <pre><code>def delete_all_processed_jobs():\n    \"\"\"Delete all processed jobs\"\"\"\n    bmr_project = get_current_project()\n    if not _PROCESSING_JOBS:\n        return\n\n    for job_id in _PROCESSING_JOBS:\n        bmr_project.DeleteRenderJob(job_id)\n\n    _PROCESSING_JOBS.clear()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html#client.ayon_resolve.api.rendering.is_rendering_in_progress","title":"<code>is_rendering_in_progress()</code>","text":"<p>Check if rendering is in progress</p> Source code in <code>client/ayon_resolve/api/rendering.py</code> <pre><code>def is_rendering_in_progress():\n    \"\"\"Check if rendering is in progress\"\"\"\n    bmr_project = get_current_project()\n    if not bmr_project:\n        return False\n\n    return bmr_project.IsRenderingInProgress()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html#client.ayon_resolve.api.rendering.render_all_timelines","title":"<code>render_all_timelines(target_render_directory)</code>","text":"<p>Render all of the timelines of current project.</p> <p>Parameters:</p> Name Type Description Default <code>target_render_directory</code> <code>Path</code> <p>Path to target render directory</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if all renders are successful, False otherwise</p> Source code in <code>client/ayon_resolve/api/rendering.py</code> <pre><code>def render_all_timelines(target_render_directory):\n    \"\"\"Render all of the timelines of current project.\n\n    Args:\n        target_render_directory (Path): Path to target render directory\n\n    Returns:\n        bool: True if all renders are successful, False otherwise\n    \"\"\"\n    bmr_project = get_current_project()\n    with maintain_page_by_name(\"Deliver\"):\n        timelineCount = bmr_project.GetTimelineCount()\n        all_timelines = [\n            bmr_project.GetTimelineByIndex(index + 1)\n            for index in range(0, int(timelineCount))\n        ]\n        return _render_timelines(all_timelines, target_render_directory)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html#client.ayon_resolve.api.rendering.render_single_timeline","title":"<code>render_single_timeline(timeline, target_render_directory)</code>","text":"<p>Render single timeline</p> <p>Process is taking a defined timeline and render it to temporary intermediate file which will be lately used by Extract Review plugin for conversion to review file.</p> <p>Parameters:</p> Name Type Description Default <code>timeline</code> <code>Timeline</code> <p>Timeline object</p> required <code>target_render_directory</code> <code>Path</code> <p>Path to target render directory</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if rendering is successful, False otherwise</p> Source code in <code>client/ayon_resolve/api/rendering.py</code> <pre><code>def render_single_timeline(timeline, target_render_directory):\n    \"\"\"Render single timeline\n\n    Process is taking a defined timeline and render it to temporary\n    intermediate file which will be lately used by Extract Review plugin\n    for conversion to review file.\n\n    Args:\n        timeline (resolve.Timeline): Timeline object\n        target_render_directory (Path): Path to target render directory\n\n    Returns:\n        bool: True if rendering is successful, False otherwise\n    \"\"\"\n    return _render_timelines([timeline], target_render_directory)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/rendering.html#client.ayon_resolve.api.rendering.wait_for_rendering_completion","title":"<code>wait_for_rendering_completion()</code>","text":"<p>Wait for rendering completion</p> Source code in <code>client/ayon_resolve/api/rendering.py</code> <pre><code>def wait_for_rendering_completion():\n    \"\"\"Wait for rendering completion\"\"\"\n    while is_rendering_in_progress():\n        time.sleep(_SLEEP_TIME)\n    return\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/api/testing_utils.html","title":"testing_utils","text":""},{"location":"autoapi/client/ayon_resolve/api/utils.html","title":"utils","text":"<p>Resolve's tools for setting environment</p>"},{"location":"autoapi/client/ayon_resolve/api/workio.html","title":"workio","text":"<p>Host API required Work Files tool</p>"},{"location":"autoapi/client/ayon_resolve/api/workio.html#client.ayon_resolve.api.workio.open_file","title":"<code>open_file(filepath)</code>","text":"<p>Loading project</p> Source code in <code>client/ayon_resolve/api/workio.py</code> <pre><code>def open_file(filepath):\n    \"\"\"\n    Loading project\n    \"\"\"\n\n    from . import bmdvr\n\n    project_manager = get_project_manager()\n    page = bmdvr.GetCurrentPage()\n    if page is not None:\n        # Save current project only if Resolve has an active page, otherwise\n        # we consider Resolve being in a pre-launch state (no open UI yet)\n        resolve_project = get_current_resolve_project()\n        print(f\"Saving current resolve project: {resolve_project}\")\n        project_manager.SaveProject()\n\n    file = os.path.basename(filepath)\n    fname, _ = os.path.splitext(file)\n\n    try:\n        # load project from input path\n        resolve_project = project_manager.LoadProject(fname)\n        log.info(f\"Project {resolve_project.GetName()} opened...\")\n\n    except AttributeError:\n        log.warning((f\"Project with name `{fname}` does not exist! It will \"\n                     f\"be imported from {filepath} and then loaded...\"))\n        if project_manager.ImportProject(filepath):\n            # load project from input path\n            resolve_project = project_manager.LoadProject(fname)\n            log.info(f\"Project imported/loaded {resolve_project.GetName()}...\")\n            return True\n        return False\n    return True\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/hooks/index.html","title":"hooks","text":""},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_last_workfile.html","title":"pre_resolve_last_workfile","text":""},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_last_workfile.html#client.ayon_resolve.hooks.pre_resolve_last_workfile.PreLaunchResolveLastWorkfile","title":"<code>PreLaunchResolveLastWorkfile</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Special hook to open last workfile for Resolve.</p> <p>Checks 'start_last_workfile', if set to False, it will not open last workfile. This property is set explicitly in Launcher.</p> Source code in <code>client/ayon_resolve/hooks/pre_resolve_last_workfile.py</code> <pre><code>class PreLaunchResolveLastWorkfile(PreLaunchHook):\n    \"\"\"Special hook to open last workfile for Resolve.\n\n    Checks 'start_last_workfile', if set to False, it will not open last\n    workfile. This property is set explicitly in Launcher.\n    \"\"\"\n    order = 10\n    app_groups = {\"resolve\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        if not self.data.get(\"start_last_workfile\"):\n            self.log.info(\"It is set to not start last workfile on start.\")\n            return\n\n        last_workfile = self.data.get(\"last_workfile_path\")\n        if not last_workfile:\n            self.log.warning(\"Last workfile was not collected.\")\n            return\n\n        if not os.path.exists(last_workfile):\n            self.log.info(\"Current context does not have any workfile yet.\")\n            return\n\n        # Add path to launch environment for the startup script to pick up\n        self.log.info(\n            \"Setting AYON_RESOLVE_OPEN_ON_LAUNCH to launch \"\n            f\"last workfile: {last_workfile}\"\n        )\n        key = \"AYON_RESOLVE_OPEN_ON_LAUNCH\"\n        self.launch_context.env[key] = last_workfile\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_setup.html","title":"pre_resolve_setup","text":""},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_setup.html#client.ayon_resolve.hooks.pre_resolve_setup.PreLaunchResolveSetup","title":"<code>PreLaunchResolveSetup</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>This hook will set up the Resolve scripting environment as described in Resolve's documentation found with the installed application at {resolve}/Support/Developer/Scripting/README.txt</p> <p>Prepares the following environment variables: - <code>RESOLVE_SCRIPT_API</code> - <code>RESOLVE_SCRIPT_LIB</code></p> <p>It adds $RESOLVE_SCRIPT_API/Modules to PYTHONPATH.</p> <p>Additionally it sets up the Python home for Python 3 based on the RESOLVE_PYTHON3_HOME in the environment (usually defined in Ayon's Application environment for Resolve by the admin). For this it sets PYTHONHOME and PATH variables.</p> <p>It also defines: - <code>RESOLVE_UTILITY_SCRIPTS_DIR</code>: Destination directory for Ayon     Fusion scripts to be copied to for Resolve to pick them up. - <code>AYON_LOG_NO_COLORS</code> to True to ensure OP doesn't try to     use logging with terminal colors as it fails in Resolve.</p> Source code in <code>client/ayon_resolve/hooks/pre_resolve_setup.py</code> <pre><code>class PreLaunchResolveSetup(PreLaunchHook):\n    \"\"\"\n    This hook will set up the Resolve scripting environment as described in\n    Resolve's documentation found with the installed application at\n    {resolve}/Support/Developer/Scripting/README.txt\n\n    Prepares the following environment variables:\n    - `RESOLVE_SCRIPT_API`\n    - `RESOLVE_SCRIPT_LIB`\n\n    It adds $RESOLVE_SCRIPT_API/Modules to PYTHONPATH.\n\n    Additionally it sets up the Python home for Python 3 based on the\n    RESOLVE_PYTHON3_HOME in the environment (usually defined in Ayon's\n    Application environment for Resolve by the admin). For this it sets\n    PYTHONHOME and PATH variables.\n\n    It also defines:\n    - `RESOLVE_UTILITY_SCRIPTS_DIR`: Destination directory for Ayon\n        Fusion scripts to be copied to for Resolve to pick them up.\n    - `AYON_LOG_NO_COLORS` to True to ensure OP doesn't try to\n        use logging with terminal colors as it fails in Resolve.\n\n    \"\"\"\n\n    app_groups = {\"resolve\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        current_platform = platform.system().lower()\n\n        programdata = self.launch_context.env.get(\"PROGRAMDATA\", \"\")\n        resolve_script_api_locations = {\n            \"windows\": (\n                f\"{programdata}/Blackmagic Design/\"\n                \"DaVinci Resolve/Support/Developer/Scripting\"\n            ),\n            \"darwin\": (\n                \"/Library/Application Support/Blackmagic Design\"\n                \"/DaVinci Resolve/Developer/Scripting\"\n            ),\n            \"linux\": \"/opt/resolve/Developer/Scripting\",\n        }\n        resolve_script_api = Path(\n            resolve_script_api_locations[current_platform]\n        )\n        self.log.info(\n            f\"setting RESOLVE_SCRIPT_API variable to {resolve_script_api}\"\n        )\n        self.launch_context.env[\n            \"RESOLVE_SCRIPT_API\"\n        ] = resolve_script_api.as_posix()\n\n        resolve_script_lib_dirs = {\n            \"windows\": (\n                \"C:/Program Files/Blackmagic Design\"\n                \"/DaVinci Resolve/fusionscript.dll\"\n            ),\n            \"darwin\": (\n                \"/Applications/DaVinci Resolve/DaVinci Resolve.app\"\n                \"/Contents/Libraries/Fusion/fusionscript.so\"\n            ),\n            \"linux\": \"/opt/resolve/libs/Fusion/fusionscript.so\",\n        }\n        resolve_script_lib = Path(resolve_script_lib_dirs[current_platform])\n        self.launch_context.env[\n            \"RESOLVE_SCRIPT_LIB\"\n        ] = resolve_script_lib.as_posix()\n        self.log.info(\n            f\"setting RESOLVE_SCRIPT_LIB variable to {resolve_script_lib}\"\n        )\n\n        # TODO: add OTIO installation from `openpype/requirements.py`\n        # making sure python &lt;3.9.* is installed at provided path\n        python3_home = Path(\n            self.launch_context.env.get(\"RESOLVE_PYTHON3_HOME\", \"\")\n        )\n\n        assert python3_home.is_dir(), (\n            \"Python 3 is not installed at the provided folder path. Either \"\n            \"make sure the `environments\\resolve.json` is having correctly \"\n            \"set `RESOLVE_PYTHON3_HOME` or make sure Python 3 is installed \"\n            f\"in given path. \\nRESOLVE_PYTHON3_HOME: `{python3_home}`\"\n        )\n        python3_home_str = python3_home.as_posix()\n        self.launch_context.env[\"PYTHONHOME\"] = python3_home_str\n        self.log.info(f\"Path to Resolve Python folder: `{python3_home_str}`\")\n\n        # add to the PYTHONPATH\n        env_pythonpath = self.launch_context.env[\"PYTHONPATH\"]\n        modules_path = Path(resolve_script_api, \"Modules\").as_posix()\n        self.launch_context.env[\n            \"PYTHONPATH\"\n        ] = f\"{modules_path}{os.pathsep}{env_pythonpath}\"\n\n        self.log.debug(f\"PYTHONPATH: {self.launch_context.env['PYTHONPATH']}\")\n\n        # add the pythonhome folder to PATH because on Windows\n        # this is needed for Py3 to be correctly detected within Resolve\n        env_path = self.launch_context.env[\"PATH\"]\n        self.log.info(f\"Adding `{python3_home_str}` to the PATH variable\")\n        self.launch_context.env[\n            \"PATH\"\n        ] = f\"{python3_home_str}{os.pathsep}{env_path}\"\n\n        self.log.debug(f\"PATH: {self.launch_context.env['PATH']}\")\n\n        resolve_utility_scripts_dirs = {\n            \"windows\": (\n                f\"{programdata}/Blackmagic Design\"\n                \"/DaVinci Resolve/Fusion/Scripts/Comp\"\n            ),\n            \"darwin\": (\n                \"/Library/Application Support/Blackmagic Design\"\n                \"/DaVinci Resolve/Fusion/Scripts/Comp\"\n            ),\n            \"linux\": \"/opt/resolve/Fusion/Scripts/Comp\",\n        }\n        resolve_utility_scripts_dir = Path(\n            resolve_utility_scripts_dirs[current_platform]\n        )\n        # setting utility scripts dir for scripts syncing\n        self.launch_context.env[\n            \"RESOLVE_UTILITY_SCRIPTS_DIR\"\n        ] = resolve_utility_scripts_dir.as_posix()\n\n        # remove terminal coloring tags\n        self.launch_context.env[\"AYON_LOG_NO_COLORS\"] = \"1\"\n\n        # Resolve Setup integration\n        setup(self.launch_context.env)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_startup.html","title":"pre_resolve_startup","text":""},{"location":"autoapi/client/ayon_resolve/hooks/pre_resolve_startup.html#client.ayon_resolve.hooks.pre_resolve_startup.PreLaunchResolveStartup","title":"<code>PreLaunchResolveStartup</code>","text":"<p>               Bases: <code>PreLaunchHook</code></p> <p>Special hook to configure startup script.</p> Source code in <code>client/ayon_resolve/hooks/pre_resolve_startup.py</code> <pre><code>class PreLaunchResolveStartup(PreLaunchHook):\n    \"\"\"Special hook to configure startup script.\n\n    \"\"\"\n    order = 11\n    app_groups = {\"resolve\"}\n    launch_types = {LaunchTypes.local}\n\n    def execute(self):\n        # Set the openpype prelaunch startup script path for easy access\n        # in the LUA .scriptlib code\n        script_path = os.path.join(RESOLVE_ADDON_ROOT, \"startup.py\")\n        key = \"AYON_RESOLVE_STARTUP_SCRIPT\"\n        self.launch_context.env[key] = script_path\n\n        self.log.info(\n            f\"Setting AYON_RESOLVE_STARTUP_SCRIPT to: {script_path}\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/otio/index.html","title":"otio","text":""},{"location":"autoapi/client/ayon_resolve/otio/davinci_export.html","title":"davinci_export","text":"<p>compatibility OpenTimelineIO 0.12.0 and older</p>"},{"location":"autoapi/client/ayon_resolve/otio/davinci_export.html#client.ayon_resolve.otio.davinci_export.create_otio_timeline","title":"<code>create_otio_timeline(resolve_project, timeline=None)</code>","text":"<p>Create otio timeline from resolve timeline</p> <p>Parameters:</p> Name Type Description Default <code>resolve_project</code> <code>Project</code> <p>resolve project</p> required <code>timeline</code> <code>Timeline</code> <p>resolve timeline. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>otio.schema.Timeline: otio timeline</p> Source code in <code>client/ayon_resolve/otio/davinci_export.py</code> <pre><code>def create_otio_timeline(resolve_project, timeline=None):\n    \"\"\"Create otio timeline from resolve timeline\n\n    Args:\n        resolve_project (resolve.Project): resolve project\n        timeline (resolve.Timeline, optional): resolve timeline. Defaults to None.\n\n    Returns:\n        otio.schema.Timeline: otio timeline\n    \"\"\"\n\n    # get current timeline\n    timeline = timeline or resolve_project.GetCurrentTimeline()\n    timeline_fps = (\n        timeline.GetSetting(\"timelineFrameRate\") or\n        resolve_project.GetSetting(\"timelineFrameRate\")\n    )\n\n    # convert timeline to otio\n    otio_timeline = _create_otio_timeline(\n        resolve_project, timeline, timeline_fps)\n\n    # loop all defined track types\n    for track_type in list(TRACK_TYPES.keys()):\n        # get total track count\n        track_count = timeline.GetTrackCount(track_type)\n\n        # loop all tracks by track indexes\n        for track_index in range(1, int(track_count) + 1):\n            # get current track name\n            track_name = timeline.GetTrackName(track_type, track_index)\n\n            # convert track to otio\n            otio_track = create_otio_track(\n                track_type, track_name)\n\n            # get all track items in current track\n            current_track_items = timeline.GetItemListInTrack(\n                track_type, track_index)\n\n            # loop available track items in current track items\n            for track_item in current_track_items:\n                # skip offline track items\n                if track_item.GetMediaPoolItem() is None:\n                    continue\n\n                # calculate real clip start\n                clip_start = track_item.GetStart() - timeline.GetStartFrame()\n\n                add_otio_gap(\n                    clip_start, otio_track, track_item, timeline)\n\n                # create otio clip and add it to track\n                otio_clip = create_otio_clip(track_item, fps=timeline_fps)\n\n                if not isinstance(otio_clip, list):\n                    otio_track.append(otio_clip)\n                else:\n                    for index, clip in enumerate(otio_clip):\n                        if index == 0:\n                            otio_track.append(clip)\n                        else:\n                            # add previous otio track to timeline\n                            otio_timeline.tracks.append(otio_track)\n                            # convert track to otio\n                            otio_track = create_otio_track(\n                                track_type, track_name)\n                            add_otio_gap(\n                                clip_start, otio_track,\n                                track_item, timeline)\n                            otio_track.append(clip)\n\n            # add track to otio timeline\n            otio_timeline.tracks.append(otio_track)\n\n    return otio_timeline\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/otio/davinci_import.html","title":"davinci_import","text":""},{"location":"autoapi/client/ayon_resolve/otio/utils.html","title":"utils","text":""},{"location":"autoapi/client/ayon_resolve/otio/utils.html#client.ayon_resolve.otio.utils.get_marker_from_clip_index","title":"<code>get_marker_from_clip_index(otio_timeline, clip_index)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>otio_timeline</code> <code>Timeline</code> <p>The otio timeline to inspect</p> required <code>clip_index</code> <code>int</code> <p>The clip index metadata to retrieve.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>(Clip, Marker)</code> <p>The associated clip and marker or (None, None)</p> Source code in <code>client/ayon_resolve/otio/utils.py</code> <pre><code>def get_marker_from_clip_index(otio_timeline, clip_index):\n    \"\"\"\n    Args:\n        otio_timeline (otio.Timeline): The otio timeline to inspect\n        clip_index (int): The clip index metadata to retrieve.\n\n    Returns:\n        tuple(otio.Clip, otio.Marker): The associated clip and marker\n            or (None, None)\n    \"\"\"\n    try:  # opentimelineio &gt;= 0.16.0\n        all_clips = otio_timeline.find_clips()\n    except AttributeError:  # legacy\n        all_clips = otio_timeline.each_clip()\n\n    # Retrieve otioClip from parent context otioTimeline\n    # See collect_current_project\n    for otio_clip in all_clips:\n        for marker in otio_clip.markers:\n            marker = unwrap_resolve_otio_marker(marker)\n            if marker.metadata.get(\"clip_index\") == clip_index:\n                return  otio_clip, marker\n\n    return None, None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/otio/utils.html#client.ayon_resolve.otio.utils.get_padding_from_path","title":"<code>get_padding_from_path(path)</code>","text":"<p>Return padding number from DaVinci Resolve sequence path style</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>int</code> <p>padding number</p> Example <p>get_padding_from_path(\"plate.[0001-1008].exr\") &gt; 4</p> Source code in <code>client/ayon_resolve/otio/utils.py</code> <pre><code>def get_padding_from_path(path):\n    \"\"\"\n    Return padding number from DaVinci Resolve sequence path style\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        int: padding number\n\n    Example:\n        get_padding_from_path(\"plate.[0001-1008].exr\") &gt; 4\n\n    \"\"\"\n    padding_pattern = \"(\\\\d+)(?=-)\"\n    if \"[\" in path:\n        return len(re.findall(padding_pattern, path).pop())\n\n    return None\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/otio/utils.html#client.ayon_resolve.otio.utils.get_reformated_path","title":"<code>get_reformated_path(path, padded=True, first=False)</code>","text":"<p>Return fixed python expression path</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>path url or simple file name</p> required <p>Returns:</p> Name Type Description <code>type</code> <p>string with reformatted path</p> Example <p>get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr</p> Source code in <code>client/ayon_resolve/otio/utils.py</code> <pre><code>def get_reformated_path(path, padded=True, first=False):\n    \"\"\"\n    Return fixed python expression path\n\n    Args:\n        path (str): path url or simple file name\n\n    Returns:\n        type: string with reformatted path\n\n    Example:\n        get_reformated_path(\"plate.[0001-1008].exr\") &gt; plate.%04d.exr\n\n    \"\"\"\n    num_pattern = r\"(\\[\\d+\\-\\d+\\])\"\n    padding_pattern = r\"(\\d+)(?=-)\"\n    first_frame_pattern = re.compile(r\"\\[(\\d+)\\-\\d+\\]\")\n\n    if \"[\" in path:\n        padding = len(re.findall(padding_pattern, path).pop())\n        if padded:\n            path = re.sub(num_pattern, f\"%0{padding}d\", path)\n        elif first:\n            first_frame = re.findall(first_frame_pattern, path, flags=0)\n            if len(first_frame) &gt;= 1:\n                first_frame = first_frame[0]\n            path = re.sub(num_pattern, first_frame, path)\n        else:\n            path = re.sub(num_pattern, \"%d\", path)\n    return path\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/otio/utils.html#client.ayon_resolve.otio.utils.unwrap_resolve_otio_marker","title":"<code>unwrap_resolve_otio_marker(marker)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>marker</code> <code>Marker</code> <p>The marker to unwrap.</p> required <p>Returns:</p> Name Type Description <code>marker</code> <code>Marker</code> <p>Conformed marker.</p> Source code in <code>client/ayon_resolve/otio/utils.py</code> <pre><code>def unwrap_resolve_otio_marker(marker):\n    \"\"\"\n    Args:\n        marker (opentimelineio.schema.Marker): The marker to unwrap.\n\n    Returns:\n        marker (opentimelineio.schema.Marker): Conformed marker.\n    \"\"\"\n    # Resolve native OTIO exporter messes up the marker\n    # dict metadata for some reasons.\n    # {dict_info} -&gt; {\"Resolve_OTIO\": {\"Note\": \"string_dict_info\"}}\n    try:\n        marker_note = marker.metadata[\"Resolve_OTIO\"][\"Note\"]\n    except KeyError:\n        return marker\n\n    marker_note_dict = json.loads(marker_note)\n    marker.metadata.update(marker_note_dict)  # prevent additional resolve keys\n    return marker\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/index.html","title":"plugins","text":""},{"location":"autoapi/client/ayon_resolve/plugins/create/index.html","title":"create","text":""},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html","title":"create_editorial_package","text":""},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage","title":"<code>CreateEditorialPackage</code>","text":"<p>               Bases: <code>ResolveCreator</code></p> <p>Create Editorial Package.</p> Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>class CreateEditorialPackage(ResolveCreator):\n    \"\"\"Create Editorial Package.\"\"\"\n\n    identifier = \"io.ayon.creators.resolve.editorial_pkg\"\n    label = \"Editorial Package\"\n    product_type = \"editorial_pkg\"\n    icon = \"camera\"\n    defaults = [\"Main\"]\n\n    def get_pre_create_attr_defs(self):\n        \"\"\"Plugin attribute definitions needed for creation.\n\n        Returns:\n            list[AbstractAttrDef]: Attribute definitions that can be tweaked\n                for created instance.\n        \"\"\"\n        return _CREATE_ATTR_DEFS\n\n    def get_attr_defs_for_instance(self, instance):\n        \"\"\"Get attribute definitions for an instance.\n\n        Args:\n            instance (CreatedInstance): Instance for which to get\n                attribute definitions.\n\n        Returns:\n            list[AbstractAttrDef]: Attribute definitions that can be tweaked\n                for created instance.\n        \"\"\"\n        return _CREATE_ATTR_DEFS\n\n    def create(self, product_name, instance_data, pre_create_data):\n        \"\"\"Create a new editorial_pkg instance.\n\n        Args:\n            product_name (str): The product name\n            instance_data (dict): The instance data.\n            pre_create_data (dict): The pre_create context data.\n        \"\"\"\n        super().create(product_name,\n                       instance_data,\n                       pre_create_data)\n\n        current_timeline = lib.get_current_timeline()\n\n        if not current_timeline:\n            raise CreatorError(\"Make sure to have an active current timeline.\")\n\n        timeline_media_pool_item = lib.get_timeline_media_pool_item(\n            current_timeline\n        )\n\n        instance_data[\"creator_attributes\"] = {\n            \"review\": pre_create_data[\"review\"]\n        }\n\n        tag_metadata = {\n            \"publish\": deepcopy(instance_data),\n        }\n        tag_metadata[\"publish\"].update(\n            get_editorial_publish_data(\n                folder_path=instance_data[\"folderPath\"],\n                product_name=product_name\n            )\n        )\n        tag_metadata[\"publish\"][\"label\"] = current_timeline.GetName()\n\n        timeline_media_pool_item.SetMetadata(\n            constants.AYON_TAG_NAME, json.dumps(tag_metadata)\n        )\n\n        new_instance = CreatedInstance(\n            self.product_type,\n            product_name,\n            tag_metadata[\"publish\"],\n            self,\n        )\n        new_instance.transient_data[\"timeline_pool_item\"] = (\n            timeline_media_pool_item)\n        self._add_instance_to_context(new_instance)\n\n    def collect_instances(self):\n        \"\"\"Collect all created instances from current timeline.\"\"\"\n        for media_pool_item in lib.iter_all_media_pool_clips():\n            data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n            if not data:\n                continue\n\n            try:\n                data = json.loads(data)\n            except json.JSONDecodeError:\n                self.log.warning(\n                    \"Failed to parse json data from media pool item: %s\",\n                    media_pool_item.GetName()\n                )\n                continue\n\n            # exclude all which are not productType editorial_pkg\n            if (\n                data.get(\"publish\", {}).get(\"productType\") != self.product_type\n            ):\n                continue\n\n            publish_data = data[\"publish\"]\n\n            # add label into instance data in case it is missing in publish\n            # data (legacy publish) or timeline was renamed.\n            publish_data[\"label\"] = media_pool_item.GetName()\n\n            # TODO: backward compatibility for legacy workflow instances\n            # add variant into instance data in case it is missing in publish\n            # data\n            if \"variant\" not in publish_data:\n                product_name = publish_data[\"productName\"]\n                product_type = publish_data[\"productType\"]\n                publish_data[\"variant\"] = product_name.split(product_type)[1]\n\n            current_instance = CreatedInstance(\n                self.product_type,\n                publish_data[\"productName\"],\n                publish_data,\n                self\n            )\n\n            current_instance.transient_data[\"timeline_pool_item\"] = (\n                media_pool_item)\n            self._add_instance_to_context(current_instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Store changes of existing instances so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Gets list of tuples. Each item\n                contain changed instance and it's changes.\n        \"\"\"\n\n        for created_inst, _changes in update_list:\n            media_pool_item = created_inst.transient_data[\n                \"timeline_pool_item\"]\n            data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n            data = json.loads(data)\n\n            data[\"publish\"].update(created_inst.data_to_store())\n\n            media_pool_item.SetMetadata(\n                constants.AYON_TAG_NAME,\n                json.dumps(data),\n            )\n\n    def remove_instances(self, instances):\n        \"\"\"Remove instance marker from track item.\n\n        Args:\n            instance(List[CreatedInstance]): Instance objects which should be\n                removed.\n        \"\"\"\n        for instance in instances:\n            self._remove_instance_from_context(instance)\n            media_pool_item = instance.transient_data[\"timeline_pool_item\"]\n\n            data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n            data = json.loads(data)\n\n            # only removing publishing data since loading data has to remain\n            data[\"publish\"] = {}\n\n            media_pool_item.SetMetadata(\n                constants.AYON_TAG_NAME,\n                json.dumps(data),\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect all created instances from current timeline.</p> Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect all created instances from current timeline.\"\"\"\n    for media_pool_item in lib.iter_all_media_pool_clips():\n        data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n        if not data:\n            continue\n\n        try:\n            data = json.loads(data)\n        except json.JSONDecodeError:\n            self.log.warning(\n                \"Failed to parse json data from media pool item: %s\",\n                media_pool_item.GetName()\n            )\n            continue\n\n        # exclude all which are not productType editorial_pkg\n        if (\n            data.get(\"publish\", {}).get(\"productType\") != self.product_type\n        ):\n            continue\n\n        publish_data = data[\"publish\"]\n\n        # add label into instance data in case it is missing in publish\n        # data (legacy publish) or timeline was renamed.\n        publish_data[\"label\"] = media_pool_item.GetName()\n\n        # TODO: backward compatibility for legacy workflow instances\n        # add variant into instance data in case it is missing in publish\n        # data\n        if \"variant\" not in publish_data:\n            product_name = publish_data[\"productName\"]\n            product_type = publish_data[\"productType\"]\n            publish_data[\"variant\"] = product_name.split(product_type)[1]\n\n        current_instance = CreatedInstance(\n            self.product_type,\n            publish_data[\"productName\"],\n            publish_data,\n            self\n        )\n\n        current_instance.transient_data[\"timeline_pool_item\"] = (\n            media_pool_item)\n        self._add_instance_to_context(current_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.create","title":"<code>create(product_name, instance_data, pre_create_data)</code>","text":"<p>Create a new editorial_pkg instance.</p> <p>Parameters:</p> Name Type Description Default <code>product_name</code> <code>str</code> <p>The product name</p> required <code>instance_data</code> <code>dict</code> <p>The instance data.</p> required <code>pre_create_data</code> <code>dict</code> <p>The pre_create context data.</p> required Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def create(self, product_name, instance_data, pre_create_data):\n    \"\"\"Create a new editorial_pkg instance.\n\n    Args:\n        product_name (str): The product name\n        instance_data (dict): The instance data.\n        pre_create_data (dict): The pre_create context data.\n    \"\"\"\n    super().create(product_name,\n                   instance_data,\n                   pre_create_data)\n\n    current_timeline = lib.get_current_timeline()\n\n    if not current_timeline:\n        raise CreatorError(\"Make sure to have an active current timeline.\")\n\n    timeline_media_pool_item = lib.get_timeline_media_pool_item(\n        current_timeline\n    )\n\n    instance_data[\"creator_attributes\"] = {\n        \"review\": pre_create_data[\"review\"]\n    }\n\n    tag_metadata = {\n        \"publish\": deepcopy(instance_data),\n    }\n    tag_metadata[\"publish\"].update(\n        get_editorial_publish_data(\n            folder_path=instance_data[\"folderPath\"],\n            product_name=product_name\n        )\n    )\n    tag_metadata[\"publish\"][\"label\"] = current_timeline.GetName()\n\n    timeline_media_pool_item.SetMetadata(\n        constants.AYON_TAG_NAME, json.dumps(tag_metadata)\n    )\n\n    new_instance = CreatedInstance(\n        self.product_type,\n        product_name,\n        tag_metadata[\"publish\"],\n        self,\n    )\n    new_instance.transient_data[\"timeline_pool_item\"] = (\n        timeline_media_pool_item)\n    self._add_instance_to_context(new_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.get_attr_defs_for_instance","title":"<code>get_attr_defs_for_instance(instance)</code>","text":"<p>Get attribute definitions for an instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance</code> <code>CreatedInstance</code> <p>Instance for which to get attribute definitions.</p> required <p>Returns:</p> Type Description <p>list[AbstractAttrDef]: Attribute definitions that can be tweaked for created instance.</p> Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def get_attr_defs_for_instance(self, instance):\n    \"\"\"Get attribute definitions for an instance.\n\n    Args:\n        instance (CreatedInstance): Instance for which to get\n            attribute definitions.\n\n    Returns:\n        list[AbstractAttrDef]: Attribute definitions that can be tweaked\n            for created instance.\n    \"\"\"\n    return _CREATE_ATTR_DEFS\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.get_pre_create_attr_defs","title":"<code>get_pre_create_attr_defs()</code>","text":"<p>Plugin attribute definitions needed for creation.</p> <p>Returns:</p> Type Description <p>list[AbstractAttrDef]: Attribute definitions that can be tweaked for created instance.</p> Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def get_pre_create_attr_defs(self):\n    \"\"\"Plugin attribute definitions needed for creation.\n\n    Returns:\n        list[AbstractAttrDef]: Attribute definitions that can be tweaked\n            for created instance.\n    \"\"\"\n    return _CREATE_ATTR_DEFS\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Remove instance marker from track item.</p> <p>Parameters:</p> Name Type Description Default <code>instance(List[CreatedInstance])</code> <p>Instance objects which should be removed.</p> required Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Remove instance marker from track item.\n\n    Args:\n        instance(List[CreatedInstance]): Instance objects which should be\n            removed.\n    \"\"\"\n    for instance in instances:\n        self._remove_instance_from_context(instance)\n        media_pool_item = instance.transient_data[\"timeline_pool_item\"]\n\n        data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n        data = json.loads(data)\n\n        # only removing publishing data since loading data has to remain\n        data[\"publish\"] = {}\n\n        media_pool_item.SetMetadata(\n            constants.AYON_TAG_NAME,\n            json.dumps(data),\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_editorial_package.html#client.ayon_resolve.plugins.create.create_editorial_package.CreateEditorialPackage.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Store changes of existing instances so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list(List[UpdateData])</code> <p>Gets list of tuples. Each item contain changed instance and it's changes.</p> required Source code in <code>client/ayon_resolve/plugins/create/create_editorial_package.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Store changes of existing instances so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Gets list of tuples. Each item\n            contain changed instance and it's changes.\n    \"\"\"\n\n    for created_inst, _changes in update_list:\n        media_pool_item = created_inst.transient_data[\n            \"timeline_pool_item\"]\n        data = media_pool_item.GetMetadata(constants.AYON_TAG_NAME)\n        data = json.loads(data)\n\n        data[\"publish\"].update(created_inst.data_to_store())\n\n        media_pool_item.SetMetadata(\n            constants.AYON_TAG_NAME,\n            json.dumps(data),\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html","title":"create_shot_clip","text":""},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.CreateShotClip","title":"<code>CreateShotClip</code>","text":"<p>               Bases: <code>ResolveCreator</code></p> <p>Publishable clip</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>class CreateShotClip(plugin.ResolveCreator):\n    \"\"\"Publishable clip\"\"\"\n\n    identifier = \"io.ayon.creators.resolve.clip\"\n    label = \"Create Publishable Clip\"\n    product_type = \"editorial\"\n    icon = \"film\"\n    defaults = [\"Main\"]\n\n    detailed_description = \"\"\"\nPublishing clips/plate, audio for new shots to project\nor updating already created from Resolve. Publishing will create \nOTIO file.\n\"\"\"\n    create_allow_thumbnail = False\n\n    def get_pre_create_attr_defs(self):\n\n        def header_label(text):\n            return f\"&lt;br&gt;&lt;b&gt;{text}&lt;/b&gt;\"\n\n        tokens_help = \"\"\"\\nUsable tokens:\n    {_clip_}: name of used clip\n    {_track_}: name of parent track layer\n    {_sequence_}: name of parent sequence (timeline)\"\"\"\n        gui_tracks = [\n            {\"value\": tr_name, \"label\": f\"Track: {tr_name}\"}\n            for tr_name in get_video_track_names()\n        ]\n\n        # Project settings might be applied to this creator via\n        # the inherited `Creator.apply_settings`\n        presets = self.presets\n\n        return [\n\n            BoolDef(\n                \"use_selection\",\n                label=\"Use only clips with &lt;b&gt;Chocolate&lt;/b&gt;  clip color\",\n                tooltip=(\n                    \"When enabled only clips of Chocolate clip color are \"\n                    \"considered.\\n\\n\"\n                    \"Acts as a replacement to 'Use selection' because \"\n                    \"Resolves API exposes no functionality to retrieve \"\n                    \"the currently selected timeline items.\"\n                ),\n                default=True\n            ),\n\n            # hierarchyData\n            UILabelDef(\n                label=header_label(\"Shot Template Keywords\")\n            ),\n            TextDef(\n                \"folder\",\n                label=\"{folder}\",\n                tooltip=\"Name of folder used for root of generated shots.\\n\"\n                        f\"{tokens_help}\",\n                default=presets.get(\"folder\", \"shots\"),\n            ),\n            TextDef(\n                \"episode\",\n                label=\"{episode}\",\n                tooltip=f\"Name of episode.\\n{tokens_help}\",\n                default=presets.get(\"episode\", \"ep01\"),\n            ),\n            TextDef(\n                \"sequence\",\n                label=\"{sequence}\",\n                tooltip=f\"Name of sequence of shots.\\n{tokens_help}\",\n                default=presets.get(\"sequence\", \"sq01\"),\n            ),\n            TextDef(\n                \"track\",\n                label=\"{track}\",\n                tooltip=f\"Name of timeline track.\\n{tokens_help}\",\n                default=presets.get(\"track\", \"{_track_}\"),\n            ),\n            TextDef(\n                \"shot\",\n                label=\"{shot}\",\n                tooltip=\"Name of shot. '#' is converted to padded number.\"\n                        f\"\\n{tokens_help}\",\n                default=presets.get(\"shot\", \"sh###\"),\n            ),\n\n            # renameHierarchy\n            UILabelDef(\n                label=header_label(\"Shot Hierarchy and Rename Settings\")\n            ),\n            TextDef(\n                \"hierarchy\",\n                label=\"Shot Parent Hierarchy\",\n                tooltip=\"Parents folder for shot root folder, \"\n                        \"Template filled with *Hierarchy Data* section\",\n                default=presets.get(\"hierarchy\", \"{folder}/{sequence}\"),\n            ),\n            BoolDef(\n                \"clipRename\",\n                label=\"Rename Shots/Clips\",\n                tooltip=\"Renaming selected clips on fly\",\n                default=presets.get(\"clipRename\", False),\n            ),\n            TextDef(\n                \"clipName\",\n                label=\"Rename Template\",\n                tooltip=\"template for creating shot names, used for \"\n                        \"renaming (use rename: on)\",\n                default=presets.get(\"clipName\", \"{sequence}{shot}\"),\n            ),\n            NumberDef(\n                \"countFrom\",\n                label=\"Count Sequence from\",\n                tooltip=\"Set where the sequence number starts from\",\n                default=presets.get(\"countFrom\", 10),\n            ),\n            NumberDef(\n                \"countSteps\",\n                label=\"Stepping Number\",\n                tooltip=\"What number is adding every new step\",\n                default=presets.get(\"countSteps\", 10),\n            ),\n\n            # verticalSync\n            UILabelDef(\n                label=header_label(\"Vertical Synchronization of Attributes\")\n            ),\n            BoolDef(\n                \"vSyncOn\",\n                label=\"Enable Vertical Sync\",\n                tooltip=\"Switch on if you want clips above \"\n                        \"each other to share its attributes\",\n                default=presets.get(\"vSyncOn\", True),\n            ),\n            EnumDef(\n                \"vSyncTrack\",\n                label=\"Hero Track\",\n                tooltip=\"Select driving track name which should \"\n                        \"be mastering all others\",\n                items=gui_tracks or [\"&lt;nothing to select&gt;\"],\n            ),\n\n            # publishSettings\n            UILabelDef(\n                label=header_label(\"Clip Publish Settings\")\n            ),\n            EnumDef(\n                \"clip_variant\",\n                label=\"Product Variant\",\n                tooltip=\"Chosen variant which will be then used for \"\n                        \"product name, if &lt;track_name&gt; \"\n                        \"is selected, name of track layer will be used\",\n                items=['&lt;track_name&gt;', 'main', 'bg', 'fg', 'bg', 'animatic'],\n            ),\n            EnumDef(\n                \"productType\",\n                label=\"Product Type\",\n                tooltip=\"How the product will be used\",\n                items=['plate'],  # it is prepared for more types\n            ),\n            EnumDef(\n                \"reviewableSource\",\n                label=\"Reviewable Source\",\n                tooltip=\"Selecting source for reviewable files.\",\n                items=(\n                    [\n                        {\"value\": None, \"label\": \"&lt; none &gt;\"},\n                        {\"value\": \"clip_media\", \"label\": \"[ Clip's media ]\"},\n                    ]\n                    + gui_tracks\n                ),\n            ),\n            BoolDef(\n                \"export_audio\",\n                label=\"Include audio\",\n                tooltip=\"Process subsets with corresponding audio\",\n                default=False,\n            ),\n            BoolDef(\n                \"sourceResolution\",\n                label=\"Source resolution\",\n                tooltip=\"Is resoloution taken from timeline or source?\",\n                default=False,\n            ),\n\n            # shotAttr\n            UILabelDef(\n                label=header_label(\"Shot Attributes\"),\n            ),\n            NumberDef(\n                \"workfileFrameStart\",\n                label=\"Workfiles Start Frame\",\n                tooltip=\"Set workfile starting frame number\",\n                default=presets.get(\"workfileFrameStart\", 1001),\n            ),\n            NumberDef(\n                \"handleStart\",\n                label=\"Handle Start (head)\",\n                tooltip=\"Handle at start of clip\",\n                default=presets.get(\"handleStart\", 0),\n            ),\n            NumberDef(\n                \"handleEnd\",\n                label=\"Handle End (tail)\",\n                tooltip=\"Handle at end of clip\",\n                default=presets.get(\"handleEnd\", 0),\n            ),\n        ]\n\n    def create(self, subset_name, instance_data, pre_create_data):\n        super(CreateShotClip, self).create(\n            subset_name,\n            instance_data,\n            pre_create_data\n        )\n\n        instance_data[\"clip_variant\"] = pre_create_data[\"clip_variant\"]\n        instance_data[\"task\"] = None\n\n        if not self.timeline:\n            raise CreatorError(\n                \"You must be in an active timeline to \"\n                \"create the publishable clips.\\n\\n\"\n                \"Go into a timeline and then reset the publisher.\"\n            )\n\n        if not self.selected:\n            if pre_create_data.get(\"use_selection\", False):\n                raise CreatorError(\n                    \"No Chocolate-colored clips found from \"\n                    \"timeline.\\n\\nTry changing clip(s) color \"\n                    \"or disable clip color restriction.\"\n                )\n            else:\n                raise CreatorError(\n                    \"No clips found on current timeline.\"\n                )\n        self.log.info(f\"Selected: {self.selected}\")\n\n        audio_clips = get_current_timeline_items(track_type=\"audio\")\n        if not audio_clips and pre_create_data.get(\"export_audio\"):\n            raise CreatorError(\n                \"You must have audio in your active \"\n                \"timeline in order to export audio.\"\n            )\n\n        # sort selected trackItems by vSync track\n        sorted_selected_track_items = []\n        unsorted_selected_track_items = []\n        v_sync_track = pre_create_data.get(\"vSyncTrack\", \"\")\n        for track_item_data in self.selected:\n            if track_item_data[\"track\"][\"name\"] in v_sync_track:\n                sorted_selected_track_items.append(track_item_data)\n            else:\n                unsorted_selected_track_items.append(track_item_data)\n\n        sorted_selected_track_items.extend(unsorted_selected_track_items)\n\n        # create media bin for compound clips (trackItems)\n        media_pool_folder = create_bin(self.timeline.GetName())\n\n        # detect enabled creators for review, plate and audio\n        shot_creator_id = \"io.ayon.creators.resolve.shot\"\n        plate_creator_id = \"io.ayon.creators.resolve.plate\"\n        audio_creator_id = \"io.ayon.creators.resolve.audio\"\n        all_creators = {\n            shot_creator_id: True,\n            plate_creator_id: True,\n            audio_creator_id: True,\n        }\n\n        instances = []\n        all_shot_instances = {}\n        vertical_clip_match = {}\n        vertical_clip_used = {}\n\n        for index, track_item_data in enumerate(sorted_selected_track_items):\n\n            # Compute and store resolution metadata from mediapool clip.\n            resolution_data = lib.get_clip_resolution_from_media_pool(track_item_data)\n            item_unique_id = track_item_data[\"clip\"][\"item\"].GetUniqueId()\n            segment_data = copy.deepcopy(instance_data)\n\n            segment_data.update({\n                \"clip_index\": item_unique_id,\n                \"clip_source_resolution\": resolution_data,\n            })\n\n            # convert track item to timeline media pool item\n            publish_clip = plugin.PublishableClip(\n                track_item_data,\n                vertical_clip_match,\n                vertical_clip_used,\n                pre_create_data,\n                media_pool_folder,\n                rename_index=index,\n                data=segment_data,  # insert additional data in segment_data\n            )\n            track_item = publish_clip.convert()\n            if track_item is None:\n                # Ignore input clips that do not convert into a track item\n                # from `PublishableClip.convert`\n                continue\n\n            self.log.info(\n                \"Processing track item data: %r (index: %r)\",\n                track_item_data,\n                index\n            )\n\n            # Delete any existing instances previously generated for the clip.\n            prev_tag_data = lib.get_timeline_item_ayon_tag(track_item)\n            if prev_tag_data:\n                for creator_id, inst_data in prev_tag_data.get(_CONTENT_ID, {}).items():\n                    creator = self.create_context.creators[creator_id]\n                    prev_instances = [\n                        inst for inst_id, inst\n                        in self.create_context.instances_by_id.items()\n                        if inst_id == inst_data[\"instance_id\"]\n                    ]\n                    creator.remove_instances(prev_instances)\n\n            # Create new product(s) instances.\n            clip_instances = {}\n\n            # disable shot creator if heroTrack is not enabled\n            all_creators[shot_creator_id] = segment_data.get(\n                \"heroTrack\", False)\n\n            # disable audio creator if audio is not enabled\n            all_creators[audio_creator_id] = (\n                segment_data.get(\"heroTrack\", False) and\n                pre_create_data.get(\"export_audio\", False)\n            )\n\n            enabled_creators = tuple(cre for cre, enabled in all_creators.items() if enabled)\n            shot_folder_path = segment_data[\"folderPath\"]\n            shot_instances = all_shot_instances.setdefault(\n                shot_folder_path, {})\n\n            for creator_id in enabled_creators:\n                creator = self.create_context.creators[creator_id]\n                sub_instance_data = copy.deepcopy(segment_data)\n                shot_folder_path = sub_instance_data[\"folderPath\"]\n                creator_attributes = sub_instance_data.setdefault(\n                    \"creator_attributes\", {})\n\n                # Shot creation\n                if creator_id == shot_creator_id:\n                    track_item_duration = track_item.GetDuration()\n                    workfileFrameStart = \\\n                        sub_instance_data[\"workfileFrameStart\"]\n                    sub_instance_data.update(\n                        {\n                            \"variant\": \"main\",\n                            \"productType\": \"shot\",\n                            \"productName\": \"shotMain\",\n                            \"label\": f\"{shot_folder_path} shotMain\",\n                        }\n                    )\n                    creator_attributes.update({\n                        \"workfileFrameStart\": workfileFrameStart,\n                        \"handleStart\": sub_instance_data[\"handleStart\"],\n                        \"handleEnd\": sub_instance_data[\"handleEnd\"],\n                        \"frameStart\": workfileFrameStart,\n                        \"frameEnd\": (workfileFrameStart +\n                            track_item_duration),\n                        \"clipIn\": track_item.GetStart(),\n                        \"clipOut\": track_item.GetEnd(),\n                        \"clipDuration\": track_item_duration,\n                        \"sourceIn\": track_item.GetLeftOffset(),\n                        \"sourceOut\": (track_item.GetLeftOffset() +\n                            track_item_duration)\n                    })\n\n                # Plate, Audio\n                # insert parent instance data to allow\n                # metadata recollection as publish time.\n                elif creator_id == plate_creator_id:\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update({\n                        \"parent_instance_id\": parenting_data[\"instance_id\"],\n                        \"label\": (\n                            f\"{sub_instance_data['folderPath']} \"\n                            f\"{sub_instance_data['productName']}\"\n                        )\n                    })\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes.update({\n                            \"review\": True,\n                            \"reviewableSource\": sub_instance_data[\n                                \"reviewableSource\"],\n                        })\n\n                elif creator_id == audio_creator_id:\n                    sub_instance_data[\"variant\"] = \"main\"\n                    sub_instance_data[\"productType\"] = \"audio\"\n                    sub_instance_data[\"productName\"] = \"audioMain\"\n\n                    parenting_data = shot_instances[shot_creator_id]\n                    sub_instance_data.update(\n                        {\n                            \"parent_instance_id\": parenting_data[\"instance_id\"],\n                            \"label\": (\n                                f\"{shot_folder_path} \"\n                                f\"{sub_instance_data['productName']}\"\n                            )\n                        }\n                    )\n                    creator_attributes[\"parentInstance\"] = parenting_data[\n                        \"label\"]\n\n                    if sub_instance_data.get(\"reviewableSource\"):\n                        creator_attributes[\"review\"] = True\n\n                instance = creator.create(sub_instance_data, None)\n                instance.transient_data[\"track_item\"] = track_item\n                self._add_instance_to_context(instance)\n\n                instance_data_to_store = instance.data_to_store()\n                shot_instances[creator_id] = instance_data_to_store\n                clip_instances[creator_id] = instance_data_to_store\n\n            # insert clip unique ID and created instances\n            # data as track_item metadata, to retrieve those\n            # during collections and publishing phases\n            lib.imprint(\n                track_item,\n                data={\n                    _CONTENT_ID: clip_instances,\n                    \"clip_index\": item_unique_id,\n                },\n            )\n            track_item.SetClipColor(constants.PUBLISH_CLIP_COLOR)\n            instances.extend(list(clip_instances.values()))\n\n        return instances\n\n    def _create_and_add_instance(self, data, creator_id,\n            timeline_item, instances):\n        \"\"\"\n        Args:\n            data (dict): The data to re-recreate the instance from.\n            creator_id (str): The creator id to use.\n            timeline_item (obj): The associated timeline item.\n            instances (list): Result instance container.\n\n        Returns:\n            CreatedInstance: The newly created instance.\n        \"\"\"\n        creator = self.create_context.creators[creator_id]\n        instance = creator.create(data, None)\n        instance.transient_data[\"track_item\"] = timeline_item\n        self._add_instance_to_context(instance)\n        instances.append(instance)\n        return instance\n\n    def _handle_legacy_marker(self, tag_data, timeline_item, instances):\n        \"\"\" Convert OpenPypeData to AYON data.\n\n        Args:\n            tag_data (dict): The legacy marker data.\n            timline_item (obj): The associated Resolve item.\n            instances (list): Result instance container.\n        \"\"\"\n        clip_instances = {}\n        item_unique_id = timeline_item.GetUniqueId()\n        tag_data.update({\n            \"task\": self.create_context.get_current_task_name(),\n            \"clip_index\": item_unique_id,\n        })\n\n        # create parent shot\n        creator_id = \"io.ayon.creators.resolve.shot\"\n        shot_data = tag_data.copy()\n        inst = self._create_and_add_instance(\n            shot_data, creator_id, timeline_item, instances)\n        clip_instances[creator_id] = inst.data_to_store()\n\n        # create children plate\n        creator_id = \"io.ayon.creators.resolve.plate\"\n        plate_data = tag_data.copy()\n        plate_data.update({\n            \"parent_instance_id\": inst[\"instance_id\"],\n            \"clip_variant\": tag_data[\"variant\"],\n            \"creator_attributes\": {\n                \"parentInstance\": inst[\"label\"],\n            }            \n        })\n        inst = self._create_and_add_instance(\n            plate_data, creator_id, timeline_item, instances)\n        clip_instances[creator_id] = inst.data_to_store()\n\n        # Update marker with new version data.\n        timeline_item.DeleteMarkersByColor(constants.AYON_MARKER_COLOR)\n        lib.imprint(\n            timeline_item,\n            data={\n                _CONTENT_ID: clip_instances,\n                \"clip_index\": item_unique_id,\n            },\n        )\n\n    def collect_instances(self):\n        \"\"\"Collect all created instances from current timeline.\"\"\"\n        all_timeline_items = lib.get_current_timeline_items()\n        instances = []\n        for timeline_item_data in all_timeline_items:\n            timeline_item = timeline_item_data[\"clip\"][\"item\"]\n\n            # get (legacy) openpype tag data\n            # Backwards compatible (Deprecated since 24/09/05)\n            tag_data = lib.get_ayon_marker(\n                timeline_item,\n                tag_name=constants.LEGACY_OPENPYPE_MARKER_NAME\n            )\n            if tag_data:\n                self._handle_legacy_marker(\n                    tag_data, timeline_item, instances)\n                continue\n\n            # get AyonData tag data \n            tag_data = lib.get_timeline_item_ayon_tag(timeline_item)\n            if not tag_data:\n                continue\n\n            for creator_id, data in tag_data.get(_CONTENT_ID, {}).items():\n                self._create_and_add_instance(\n                        data, creator_id, timeline_item, instances)\n\n        return instances\n\n    def update_instances(self, update_list):\n        \"\"\"Never called, update is handled via _ResolveInstanceCreator.\"\"\"\n        pass\n\n    def remove_instances(self, instances):\n        \"\"\"Never called, removal is handled via _ResolveInstanceCreator.\"\"\"\n        pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.CreateShotClip.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect all created instances from current timeline.</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect all created instances from current timeline.\"\"\"\n    all_timeline_items = lib.get_current_timeline_items()\n    instances = []\n    for timeline_item_data in all_timeline_items:\n        timeline_item = timeline_item_data[\"clip\"][\"item\"]\n\n        # get (legacy) openpype tag data\n        # Backwards compatible (Deprecated since 24/09/05)\n        tag_data = lib.get_ayon_marker(\n            timeline_item,\n            tag_name=constants.LEGACY_OPENPYPE_MARKER_NAME\n        )\n        if tag_data:\n            self._handle_legacy_marker(\n                tag_data, timeline_item, instances)\n            continue\n\n        # get AyonData tag data \n        tag_data = lib.get_timeline_item_ayon_tag(timeline_item)\n        if not tag_data:\n            continue\n\n        for creator_id, data in tag_data.get(_CONTENT_ID, {}).items():\n            self._create_and_add_instance(\n                    data, creator_id, timeline_item, instances)\n\n    return instances\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.CreateShotClip.remove_instances","title":"<code>remove_instances(instances)</code>","text":"<p>Never called, removal is handled via _ResolveInstanceCreator.</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>def remove_instances(self, instances):\n    \"\"\"Never called, removal is handled via _ResolveInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.CreateShotClip.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Never called, update is handled via _ResolveInstanceCreator.</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Never called, update is handled via _ResolveInstanceCreator.\"\"\"\n    pass\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.EditorialAudioInstanceCreator","title":"<code>EditorialAudioInstanceCreator</code>","text":"<p>               Bases: <code>_ResolveInstanceClipCreatorBase</code></p> <p>Audio product type creator class</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialAudioInstanceCreator(_ResolveInstanceClipCreatorBase):\n    \"\"\"Audio product type creator class\"\"\"\n    identifier = \"io.ayon.creators.resolve.audio\"\n    product_type = \"audio\"\n    label = \"Editorial Audio\"\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.EditorialPlateInstanceCreator","title":"<code>EditorialPlateInstanceCreator</code>","text":"<p>               Bases: <code>_ResolveInstanceClipCreatorBase</code></p> <p>Plate product type creator class</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>class EditorialPlateInstanceCreator(_ResolveInstanceClipCreatorBase):\n    \"\"\"Plate product type creator class\"\"\"\n    identifier = \"io.ayon.creators.resolve.plate\"\n    product_type = \"plate\"\n    label = \"Editorial Plate\"\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_shot_clip.html#client.ayon_resolve.plugins.create.create_shot_clip.ResolveShotInstanceCreator","title":"<code>ResolveShotInstanceCreator</code>","text":"<p>               Bases: <code>_ResolveInstanceClipCreator</code></p> <p>Shot product type creator class</p> Source code in <code>client/ayon_resolve/plugins/create/create_shot_clip.py</code> <pre><code>class ResolveShotInstanceCreator(_ResolveInstanceClipCreator):\n    \"\"\"Shot product type creator class\"\"\"\n    identifier = \"io.ayon.creators.resolve.shot\"\n    product_type = \"shot\"    \n    label = \"Editorial Shot\"\n\n    def get_instance_attr_defs(self):\n        instance_attributes = CLIP_ATTR_DEFS\n        return instance_attributes\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_workfile.html","title":"create_workfile","text":"<p>Creator plugin for creating workfiles.</p>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_workfile.html#client.ayon_resolve.plugins.create.create_workfile.CreateWorkfile","title":"<code>CreateWorkfile</code>","text":"<p>               Bases: <code>AutoCreator</code></p> <p>Workfile auto-creator.</p> Source code in <code>client/ayon_resolve/plugins/create/create_workfile.py</code> <pre><code>class CreateWorkfile(AutoCreator):\n    \"\"\"Workfile auto-creator.\"\"\"\n    settings_category = \"resolve\"\n\n    identifier = \"io.ayon.creators.resolve.workfile\"\n    label = \"Workfile\"\n    product_type = \"workfile\"\n\n    default_variant = \"Main\"\n\n    def _dumps_data_as_project_setting(self, data):\n        \"\"\"Store workfile as project setting.\n\n        Args:\n            data (dict): The data to store on the timeline.\n        \"\"\"\n        # Store info as project setting data.\n        # Use this hack instead: \n        # https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;t=\n        # 189685&amp;hilit=python+database#p991541\n        note = json.dumps(data)\n        proj = lib.get_current_project()\n        proj.SetSetting(\"colorVersion10Name\", note)\n\n    def _loads_data_from_project_setting(self):\n        \"\"\"Retrieve workfile data from project setting.\"\"\"\n        proj = lib.get_current_project()\n        setting_content = proj.GetSetting(\"colorVersion10Name\")\n\n        if setting_content:\n            return json.loads(setting_content)\n\n        return None\n\n    def _create_new_instance(self):\n        \"\"\"Create new instance.\"\"\"\n        variant = self.default_variant\n        project_name = self.create_context.get_current_project_name()\n        host_name = self.create_context.host_name\n        folder_entity = self.create_context.get_current_folder_entity()\n        task_entity = self.create_context.get_current_task_entity()\n        folder_path = folder_entity[\"path\"]\n        task_name = task_entity[\"name\"]\n        product_name = self.get_product_name(\n            project_name,\n            folder_entity,\n            task_entity,\n            self.default_variant,\n            host_name,\n        )\n        data = {\n            \"folderPath\": folder_path,\n            \"task\": task_name,\n            \"variant\": variant,\n            \"productName\": product_name,\n        }\n        data.update(\n            self.get_dynamic_data(\n                variant,\n                task_name,\n                folder_entity,\n                project_name,\n                host_name,\n                False,\n            )\n        )\n\n        return data\n\n    def collect_instances(self):\n        \"\"\"Collect from timeline marker or create a new one.\"\"\"\n        data = self._loads_data_from_project_setting()\n        if not data:\n            return\n\n        current_instance = CreatedInstance(\n            self.product_type, data[\"productName\"], data, self)\n        self._add_instance_to_context(current_instance)\n\n    def create(self, options=None):\n        \"\"\"Auto-create an instance by default.\"\"\"\n        data = self._loads_data_from_project_setting()\n        if data:\n            return\n\n        self.log.info(\"Auto-creating workfile instance...\")\n        data = self._create_new_instance()\n        current_instance = CreatedInstance(\n            self.product_type, data[\"productName\"], data, self)\n        self._add_instance_to_context(current_instance)\n\n    def update_instances(self, update_list):\n        \"\"\"Store changes in project metadata so they can be recollected.\n\n        Args:\n            update_list(List[UpdateData]): Gets list of tuples. Each item\n                contain changed instance and its changes.\n        \"\"\"\n        for created_inst, _ in update_list:\n            data = created_inst.data_to_store()\n            self._dumps_data_as_project_setting(data)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_workfile.html#client.ayon_resolve.plugins.create.create_workfile.CreateWorkfile.collect_instances","title":"<code>collect_instances()</code>","text":"<p>Collect from timeline marker or create a new one.</p> Source code in <code>client/ayon_resolve/plugins/create/create_workfile.py</code> <pre><code>def collect_instances(self):\n    \"\"\"Collect from timeline marker or create a new one.\"\"\"\n    data = self._loads_data_from_project_setting()\n    if not data:\n        return\n\n    current_instance = CreatedInstance(\n        self.product_type, data[\"productName\"], data, self)\n    self._add_instance_to_context(current_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_workfile.html#client.ayon_resolve.plugins.create.create_workfile.CreateWorkfile.create","title":"<code>create(options=None)</code>","text":"<p>Auto-create an instance by default.</p> Source code in <code>client/ayon_resolve/plugins/create/create_workfile.py</code> <pre><code>def create(self, options=None):\n    \"\"\"Auto-create an instance by default.\"\"\"\n    data = self._loads_data_from_project_setting()\n    if data:\n        return\n\n    self.log.info(\"Auto-creating workfile instance...\")\n    data = self._create_new_instance()\n    current_instance = CreatedInstance(\n        self.product_type, data[\"productName\"], data, self)\n    self._add_instance_to_context(current_instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/create/create_workfile.html#client.ayon_resolve.plugins.create.create_workfile.CreateWorkfile.update_instances","title":"<code>update_instances(update_list)</code>","text":"<p>Store changes in project metadata so they can be recollected.</p> <p>Parameters:</p> Name Type Description Default <code>update_list(List[UpdateData])</code> <p>Gets list of tuples. Each item contain changed instance and its changes.</p> required Source code in <code>client/ayon_resolve/plugins/create/create_workfile.py</code> <pre><code>def update_instances(self, update_list):\n    \"\"\"Store changes in project metadata so they can be recollected.\n\n    Args:\n        update_list(List[UpdateData]): Gets list of tuples. Each item\n            contain changed instance and its changes.\n    \"\"\"\n    for created_inst, _ in update_list:\n        data = created_inst.data_to_store()\n        self._dumps_data_as_project_setting(data)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/inventory/index.html","title":"inventory","text":""},{"location":"autoapi/client/ayon_resolve/plugins/inventory/remove_unused_media_pool_items.html","title":"remove_unused_media_pool_items","text":""},{"location":"autoapi/client/ayon_resolve/plugins/load/index.html","title":"load","text":""},{"location":"autoapi/client/ayon_resolve/plugins/load/load_clip.html","title":"load_clip","text":""},{"location":"autoapi/client/ayon_resolve/plugins/load/load_clip.html#client.ayon_resolve.plugins.load.load_clip.LoadClip","title":"<code>LoadClip</code>","text":"<p>               Bases: <code>TimelineItemLoader</code></p> <p>Load a product to timeline as clip</p> <p>Place clip to timeline on its asset origin timings collected during conforming to project</p> Source code in <code>client/ayon_resolve/plugins/load/load_clip.py</code> <pre><code>class LoadClip(plugin.TimelineItemLoader):\n    \"\"\"Load a product to timeline as clip\n\n    Place clip to timeline on its asset origin timings collected\n    during conforming to project\n    \"\"\"\n\n    product_types = {\"render2d\", \"source\", \"plate\", \"render\", \"review\"}\n\n    representations = {\"*\"}\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load as clip\"\n    order = -10\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    # for loader multiselection\n    timeline = None\n\n    # presets\n    clip_color_last = \"Olive\"\n    clip_color = \"Orange\"\n\n    def load(self, context, name, namespace, options):\n\n        # load clip to timeline and get main variables\n        files = plugin.get_representation_files(\n            context[\"project\"][\"name\"],\n            context[\"representation\"]\n        )\n\n        timeline_item = plugin.ClipLoader(\n            self, context, **options).load(files)\n        namespace = namespace or timeline_item.GetName()\n\n        # update color of clip regarding the version order\n        self.set_item_color(\n            context[\"project\"][\"name\"],\n            timeline_item,\n            context[\"version\"]\n        )\n\n        data_imprint = self.get_tag_data(context, name, namespace)\n        return containerise(\n            timeline_item,\n            name, namespace, context,\n            self.__class__.__name__,\n            data_imprint)\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        \"\"\" Updating previously loaded clips\n        \"\"\"\n\n        repre_entity = context[\"representation\"]\n        name = container['name']\n        namespace = container['namespace']\n        timeline_item = container[\"_timeline_item\"]\n\n        media_pool_item = timeline_item.GetMediaPoolItem()\n\n        files = plugin.get_representation_files(\n            context[\"project\"][\"name\"],\n            repre_entity\n        )\n\n        loader = plugin.ClipLoader(self, context)\n        timeline_item = loader.update(timeline_item, files)\n\n        # update color of clip regarding the version order\n        self.set_item_color(\n            context[\"project\"][\"name\"],\n            timeline_item,\n            context[\"version\"]\n        )\n\n        # if original media pool item has no remaining usages left\n        # remove it from the media pool\n        if int(media_pool_item.GetClipProperty(\"Usage\")) == 0:\n            lib.remove_media_pool_item(media_pool_item)\n\n        data_imprint = self.get_tag_data(context, name, namespace)\n        return update_container(timeline_item, data_imprint)\n\n    def get_tag_data(self, context, name, namespace):\n        \"\"\"Return data to be imprinted on the timeline item marker\"\"\"\n\n        repre_entity = context[\"representation\"]\n        version_entity = context[\"version\"]\n        version_attributes = version_entity[\"attrib\"]\n        colorspace = version_attributes.get(\"colorSpace\", None)\n        object_name = \"{}_{}\".format(name, namespace)\n\n        # add additional metadata from the version to imprint Avalon knob\n        # move all version data keys to tag data\n        add_version_data_keys = [\n            \"frameStart\", \"frameEnd\", \"source\", \"author\",\n            \"fps\", \"handleStart\", \"handleEnd\"\n        ]\n        data = {\n            key: version_attributes.get(key, \"None\")\n            for key in add_version_data_keys\n        }\n\n        # add variables related to version context\n        data.update({\n            \"representation\": repre_entity[\"id\"],\n            \"version\": version_entity[\"version\"],\n            \"colorspace\": colorspace,\n            \"objectName\": object_name\n        })\n        return data\n\n    @classmethod\n    def set_item_color(cls, project_name, timeline_item, version_entity):\n        \"\"\"Color timeline item based on whether it is outdated or latest\"\"\"\n        # get all versions in list\n        last_version_entity = ayon_api.get_last_version_by_product_id(\n            project_name,\n            version_entity[\"productId\"],\n            fields=[\"name\"]\n        )\n        last_version_id = None\n        if last_version_entity:\n            last_version_id = last_version_entity[\"id\"]\n\n        # set clip colour\n        if version_entity[\"id\"] == last_version_id:\n            timeline_item.SetClipColor(cls.clip_color_last)\n        else:\n            timeline_item.SetClipColor(cls.clip_color)\n\n    def remove(self, container):\n        timeline_item = container[\"_timeline_item\"]\n        media_pool_item = timeline_item.GetMediaPoolItem()\n        timeline = lib.get_current_timeline()\n\n        # DeleteClips function was added in Resolve 18.5+\n        # by checking None we can detect whether the\n        # function exists in Resolve\n        if timeline.DeleteClips is not None:\n            timeline.DeleteClips([timeline_item])\n        else:\n            # Resolve versions older than 18.5 can't delete clips via API\n            # so all we can do is just remove the ayon marker to 'untag' it\n            if lib.get_ayon_marker(timeline_item):\n                # Note: We must call `get_ayon_marker` because\n                # `delete_ayon_marker` uses a global variable set by\n                # `get_ayon_marker` to delete the right marker\n                # TODO: Improve code to avoid the global `temp_marker_frame`\n                lib.delete_ayon_marker(timeline_item)\n\n        # if media pool item has no remaining usages left\n        # remove it from the media pool\n        if int(media_pool_item.GetClipProperty(\"Usage\")) == 0:\n            lib.remove_media_pool_item(media_pool_item)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_clip.html#client.ayon_resolve.plugins.load.load_clip.LoadClip.get_tag_data","title":"<code>get_tag_data(context, name, namespace)</code>","text":"<p>Return data to be imprinted on the timeline item marker</p> Source code in <code>client/ayon_resolve/plugins/load/load_clip.py</code> <pre><code>def get_tag_data(self, context, name, namespace):\n    \"\"\"Return data to be imprinted on the timeline item marker\"\"\"\n\n    repre_entity = context[\"representation\"]\n    version_entity = context[\"version\"]\n    version_attributes = version_entity[\"attrib\"]\n    colorspace = version_attributes.get(\"colorSpace\", None)\n    object_name = \"{}_{}\".format(name, namespace)\n\n    # add additional metadata from the version to imprint Avalon knob\n    # move all version data keys to tag data\n    add_version_data_keys = [\n        \"frameStart\", \"frameEnd\", \"source\", \"author\",\n        \"fps\", \"handleStart\", \"handleEnd\"\n    ]\n    data = {\n        key: version_attributes.get(key, \"None\")\n        for key in add_version_data_keys\n    }\n\n    # add variables related to version context\n    data.update({\n        \"representation\": repre_entity[\"id\"],\n        \"version\": version_entity[\"version\"],\n        \"colorspace\": colorspace,\n        \"objectName\": object_name\n    })\n    return data\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_clip.html#client.ayon_resolve.plugins.load.load_clip.LoadClip.set_item_color","title":"<code>set_item_color(project_name, timeline_item, version_entity)</code>  <code>classmethod</code>","text":"<p>Color timeline item based on whether it is outdated or latest</p> Source code in <code>client/ayon_resolve/plugins/load/load_clip.py</code> <pre><code>@classmethod\ndef set_item_color(cls, project_name, timeline_item, version_entity):\n    \"\"\"Color timeline item based on whether it is outdated or latest\"\"\"\n    # get all versions in list\n    last_version_entity = ayon_api.get_last_version_by_product_id(\n        project_name,\n        version_entity[\"productId\"],\n        fields=[\"name\"]\n    )\n    last_version_id = None\n    if last_version_entity:\n        last_version_id = last_version_entity[\"id\"]\n\n    # set clip colour\n    if version_entity[\"id\"] == last_version_id:\n        timeline_item.SetClipColor(cls.clip_color_last)\n    else:\n        timeline_item.SetClipColor(cls.clip_color)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_clip.html#client.ayon_resolve.plugins.load.load_clip.LoadClip.update","title":"<code>update(container, context)</code>","text":"<p>Updating previously loaded clips</p> Source code in <code>client/ayon_resolve/plugins/load/load_clip.py</code> <pre><code>def update(self, container, context):\n    \"\"\" Updating previously loaded clips\n    \"\"\"\n\n    repre_entity = context[\"representation\"]\n    name = container['name']\n    namespace = container['namespace']\n    timeline_item = container[\"_timeline_item\"]\n\n    media_pool_item = timeline_item.GetMediaPoolItem()\n\n    files = plugin.get_representation_files(\n        context[\"project\"][\"name\"],\n        repre_entity\n    )\n\n    loader = plugin.ClipLoader(self, context)\n    timeline_item = loader.update(timeline_item, files)\n\n    # update color of clip regarding the version order\n    self.set_item_color(\n        context[\"project\"][\"name\"],\n        timeline_item,\n        context[\"version\"]\n    )\n\n    # if original media pool item has no remaining usages left\n    # remove it from the media pool\n    if int(media_pool_item.GetClipProperty(\"Usage\")) == 0:\n        lib.remove_media_pool_item(media_pool_item)\n\n    data_imprint = self.get_tag_data(context, name, namespace)\n    return update_container(timeline_item, data_imprint)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_editorial_package.html","title":"load_editorial_package","text":""},{"location":"autoapi/client/ayon_resolve/plugins/load/load_editorial_package.html#client.ayon_resolve.plugins.load.load_editorial_package.LoadEditorialPackage","title":"<code>LoadEditorialPackage</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load editorial package to timeline.</p> <p>Loading timeline from OTIO file included media sources and timeline structure.</p> Source code in <code>client/ayon_resolve/plugins/load/load_editorial_package.py</code> <pre><code>class LoadEditorialPackage(load.LoaderPlugin):\n    \"\"\"Load editorial package to timeline.\n\n    Loading timeline from OTIO file included media sources\n    and timeline structure.\n    \"\"\"\n\n    product_types = {\"editorial_pkg\"}\n\n    representations = {\"*\"}\n    extensions = {\"otio\"}\n\n    label = \"Load as Timeline\"\n    order = -10\n    icon = \"ei.align-left\"\n    color = \"orange\"\n\n    def load(self, context, name, namespace, data):\n        files = get_representation_path(context[\"representation\"])\n\n        search_folder_path = Path(files).parent / \"resources\"\n        if not search_folder_path.exists():\n            search_folder_path = Path(files).parent\n\n        project = lib.get_current_project()\n        media_pool = project.GetMediaPool()\n        folder_path = context[\"folder\"][\"path\"]\n\n        # create versioned bin for editorial package\n        version_name = context[\"version\"][\"name\"]\n        loaded_bin = lib.create_bin(f\"{folder_path}/{name}/{version_name}\")\n\n        # make timeline unique name based on folder path\n        folder_path_name = folder_path.replace(\"/\", \"_\").lstrip(\"_\")\n        loaded_timeline_name = (\n            f\"{folder_path_name}_{name}_{version_name}_timeline\")\n        import_options = {\n            \"timelineName\": loaded_timeline_name,\n            \"importSourceClips\": True,\n            \"sourceClipsPath\": search_folder_path.as_posix(),\n        }\n\n        # import timeline from otio file\n        timeline = media_pool.ImportTimelineFromFile(files, import_options)\n\n        # get timeline media pool item for metadata update\n        timeline_media_pool_item = lib.get_timeline_media_pool_item(\n            timeline, loaded_bin\n        )\n\n        # Update the metadata\n        clip_data = self._get_container_data(\n            context, data)\n\n        timeline_media_pool_item.SetMetadata(\n            constants.AYON_TAG_NAME, json.dumps(clip_data)\n        )\n\n        # set clip color based on random choice\n        clip_color = self.get_random_clip_color()\n        timeline_media_pool_item.SetClipColor(clip_color)\n\n        # TODO: there are two ways to import timeline resources (representation\n        #   and resources folder) but Resolve seems to ignore any of this\n        #   since it is importing sources automatically. But we might need\n        #   to at least set some metadata to those loaded media pool items\n        print(\"Timeline imported: \", timeline)\n\n    def update(self, container, context):\n        \"\"\"Update the container with the latest version.\"\"\"\n\n        # Get the latest version of the container data\n        timeline_media_pool_item = container[\"_item\"]\n        clip_data = timeline_media_pool_item.GetMetadata(\n            constants.AYON_TAG_NAME)\n        clip_data = json.loads(clip_data)\n\n        clip_data[\"load\"] = {}\n\n        # update publish key in publish container data to be False\n        if clip_data[\"publish\"][\"publish\"] is True:\n            clip_data[\"publish\"][\"publish\"] = False\n\n        timeline_media_pool_item.SetMetadata(\n            constants.AYON_TAG_NAME, json.dumps(clip_data))\n\n        self.load(\n            context,\n            context[\"product\"][\"name\"],\n            container[\"namespace\"],\n            container\n        )\n\n    def _get_container_data(\n        self,\n        context: dict,\n        data: dict\n    ) -&gt; dict:\n        \"\"\"Return metadata related to the representation and version.\"\"\"\n\n        # add additional metadata from the version to imprint AYON knob\n        version_entity = context[\"version\"]\n\n        for key in (\"_item\", \"name\"):\n            data.pop(key, None)  # remove unnecessary key from the data if it exists\n\n        data = {\n            \"load\": data,\n        }\n\n        # add version attributes to the load data\n        data[\"load\"].update(\n            version_entity[\"attrib\"]\n        )\n\n        # add variables related to version context\n        data[\"load\"].update(\n            {\n                \"schema\": \"ayon:container-3.0\",\n                \"id\": AVALON_CONTAINER_ID,\n                \"loader\": str(self.__class__.__name__),\n                \"author\": version_entity[\"data\"][\"author\"],\n                \"representation\": context[\"representation\"][\"id\"],\n                \"version\": version_entity[\"version\"],\n            }\n        )\n\n        # add publish data for streamline publishing\n        data[\"publish\"] = get_editorial_publish_data(\n            folder_path=context[\"folder\"][\"path\"],\n            product_name=context[\"product\"][\"name\"],\n            version=version_entity[\"version\"],\n            task=context[\"representation\"][\"context\"].get(\"task\", {}).get(\n                \"name\"),\n        )\n\n        return data\n\n    def get_random_clip_color(self):\n        \"\"\"Return clip color.\"\"\"\n\n        # list of all available davinci resolve clip colors\n        colors = [\n            \"Orange\",\n            \"Apricot\"\n            \"Yellow\",\n            \"Lime\",\n            \"Olive\",\n            \"Green\",\n            \"Teal\",\n            \"Navy\",\n            \"Blue\",\n            \"Purple\",\n            \"Violet\",\n            \"Pink\",\n            \"Tan\",\n            \"Beige\",\n            \"Brown\",\n            \"Chocolate\",\n        ]\n\n        # return one of the colors based on random position\n        return random.choice(colors)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_editorial_package.html#client.ayon_resolve.plugins.load.load_editorial_package.LoadEditorialPackage.get_random_clip_color","title":"<code>get_random_clip_color()</code>","text":"<p>Return clip color.</p> Source code in <code>client/ayon_resolve/plugins/load/load_editorial_package.py</code> <pre><code>def get_random_clip_color(self):\n    \"\"\"Return clip color.\"\"\"\n\n    # list of all available davinci resolve clip colors\n    colors = [\n        \"Orange\",\n        \"Apricot\"\n        \"Yellow\",\n        \"Lime\",\n        \"Olive\",\n        \"Green\",\n        \"Teal\",\n        \"Navy\",\n        \"Blue\",\n        \"Purple\",\n        \"Violet\",\n        \"Pink\",\n        \"Tan\",\n        \"Beige\",\n        \"Brown\",\n        \"Chocolate\",\n    ]\n\n    # return one of the colors based on random position\n    return random.choice(colors)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_editorial_package.html#client.ayon_resolve.plugins.load.load_editorial_package.LoadEditorialPackage.update","title":"<code>update(container, context)</code>","text":"<p>Update the container with the latest version.</p> Source code in <code>client/ayon_resolve/plugins/load/load_editorial_package.py</code> <pre><code>def update(self, container, context):\n    \"\"\"Update the container with the latest version.\"\"\"\n\n    # Get the latest version of the container data\n    timeline_media_pool_item = container[\"_item\"]\n    clip_data = timeline_media_pool_item.GetMetadata(\n        constants.AYON_TAG_NAME)\n    clip_data = json.loads(clip_data)\n\n    clip_data[\"load\"] = {}\n\n    # update publish key in publish container data to be False\n    if clip_data[\"publish\"][\"publish\"] is True:\n        clip_data[\"publish\"][\"publish\"] = False\n\n    timeline_media_pool_item.SetMetadata(\n        constants.AYON_TAG_NAME, json.dumps(clip_data))\n\n    self.load(\n        context,\n        context[\"product\"][\"name\"],\n        container[\"namespace\"],\n        container\n    )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html","title":"load_media","text":""},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.LoadMedia","title":"<code>LoadMedia</code>","text":"<p>               Bases: <code>LoaderPlugin</code></p> <p>Load product as media pool item.</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>class LoadMedia(LoaderPlugin):\n    \"\"\"Load product as media pool item.\"\"\"\n\n    product_types = {\"render2d\", \"source\", \"plate\", \"render\", \"review\"}\n\n    representations = [\"*\"]\n    extensions = set(\n        ext.lstrip(\".\") for ext in IMAGE_EXTENSIONS.union(VIDEO_EXTENSIONS)\n    )\n\n    label = \"Load media\"\n    order = -20\n    icon = \"code-fork\"\n    color = \"orange\"\n\n    options = [\n        BoolDef(\n            \"load_to_timeline\",\n            label=\"Load to timeline\",\n            default=True,\n            tooltip=\"Whether on load to automatically add it to the current \"\n                    \"timeline\"\n        ),\n        BoolDef(\n            \"load_once\",\n            label=\"Re-use existing\",\n            default=True,\n            tooltip=\"When enabled - if this particular version is already\"\n                    \"loaded it will not be loaded again but will be re-used.\"\n        )\n    ]\n\n    # for loader multiselection\n    timeline = None\n\n    # presets\n    clip_color_last = \"Olive\"\n    clip_color_old = \"Orange\"\n\n    media_pool_bin_path = \"Loader/{folder[path]}\"\n\n    metadata: List[MetadataEntry] = []\n\n    # cached on apply settings\n    _host_imageio_settings = None\n\n    @classmethod\n    def apply_settings(cls, project_settings):\n        super(LoadMedia, cls).apply_settings(project_settings)\n        cls._host_imageio_settings = project_settings[\"resolve\"][\"imageio\"]\n\n    def load(self, context, name, namespace, options):\n\n        # For loading multiselection, we store timeline before first load\n        # because the current timeline can change with the imported media.\n        if self.timeline is None:\n            self.timeline = lib.get_current_timeline()\n\n        representation = context[\"representation\"]\n        self._project_name = context[\"project\"][\"name\"]\n\n        project = lib.get_current_project()\n        media_pool = project.GetMediaPool()\n\n        # Allow to use an existing media pool item and re-use it\n        item = None\n        if options.get(\"load_once\", True):\n            host = registered_host()\n            repre_id = context[\"representation\"][\"id\"]\n            for container in host.ls():\n                if container[\"representation\"] != repre_id:\n                    continue\n\n                if container[\"loader\"] != self.__class__.__name__:\n                    continue\n\n                print(f\"Re-using existing container: {container}\")\n                item = container[\"_item\"]\n\n        if item is None:\n            item = self._import_media_to_bin(context, media_pool, representation)\n        # Always update clip color - even if re-using existing clip\n        color = self.get_item_color(context)\n        item.SetClipColor(color)\n\n        if options.get(\"load_to_timeline\", True):\n            timeline = options.get(\"timeline\", self.timeline)\n            if timeline:\n                # Add media to active timeline\n                lib.create_timeline_item(\n                    media_pool_item=item,\n                    timeline=timeline\n                )\n\n    def _import_media_to_bin(\n        self, context, media_pool, representation\n    ):\n        \"\"\"Import media to Resolve Media Pool.\n\n        Also create a bin if `media_pool_bin_path` is set.\n\n        Args:\n            context (dict): The context dictionary.\n            media_pool (resolve.MediaPool): The Resolve Media Pool.\n            representation (dict): The representation data.\n\n        Returns:\n            resolve.MediaPoolItem: The imported media pool item.\n        \"\"\"\n        # Create or set the bin folder, we add it in there\n        # If bin path is not set we just add into the current active bin\n        if self.media_pool_bin_path:\n            media_pool_bin_path = StringTemplate(\n                self.media_pool_bin_path).format_strict(context)\n\n            folder = lib.create_bin(\n                # double slashes will create unconnected folders\n                name=media_pool_bin_path.replace(\"//\", \"/\"),\n                root=media_pool.GetRootFolder(),\n                set_as_current=False\n            )\n            media_pool.SetCurrentFolder(folder)\n\n        # Import media\n        # Resolve API: ImportMedia function requires a list of dictionaries\n        # with keys \"FilePath\", \"StartIndex\" and \"EndIndex\" for sequences\n        # but only string with absolute path for single files.\n        is_sequence, file_info = self._get_file_info(context)\n        items = (\n            media_pool.ImportMedia([file_info])\n            if is_sequence\n            else media_pool.ImportMedia([file_info[\"FilePath\"]])\n        )\n        assert len(items) == 1, \"Must import only one media item\"\n\n        result = items[0]\n\n        self._set_metadata(result, context)\n        self._set_colorspace_from_representation(result, representation)\n\n        data = self._get_container_data(context)\n\n        # Add containerise data only needed on first load\n        data.update({\n            \"schema\": \"openpype:container-2.0\",\n            \"id\": AVALON_CONTAINER_ID,\n            \"loader\": str(self.__class__.__name__),\n        })\n\n        result.SetMetadata(constants.AYON_TAG_NAME, json.dumps(data))\n\n        return result\n\n    def switch(self, container, context):\n        self.update(container, context)\n\n    def update(self, container, context):\n        # Update MediaPoolItem filepath and metadata\n        item = container[\"_item\"]\n\n        # Get the existing metadata before we update because the\n        # metadata gets removed\n        data = json.loads(item.GetMetadata(constants.AYON_TAG_NAME))\n\n        # Get metadata to preserve after the clip replacement\n        # TODO: Maybe preserve more, like LUT, Alpha Mode, Input Sizing Preset\n        colorspace_before = item.GetClipProperty(\"Input Color Space\")\n\n        # Update path\n        path = get_representation_path(context[\"representation\"])\n        success = item.ReplaceClip(path)\n        if not success:\n            raise RuntimeError(\n                f\"Failed to replace media pool item clip to filepath: {path}\"\n            )\n\n        # Update the metadata\n        update_data = self._get_container_data(context)\n        data.update(update_data)\n        item.SetMetadata(constants.AYON_TAG_NAME, json.dumps(data))\n\n        self._set_metadata(media_pool_item=item, context=context)\n        self._set_colorspace_from_representation(\n            item,\n            representation=context[\"representation\"]\n        )\n\n        # If no specific colorspace is set then we want to preserve the\n        # colorspace a user might have set before the clip replacement\n        if (\n                item.GetClipProperty(\"Input Color Space\") == \"Project\"\n                and colorspace_before != \"Project\"\n        ):\n            result = set_colorspace(item, colorspace_before)\n            if not result:\n                self.log.warning(\n                    f\"Failed to re-apply colorspace: {colorspace_before}.\"\n                )\n\n        # Update the clip color\n        color = self.get_item_color(context)\n        item.SetClipColor(color)\n\n    def remove(self, container):\n        # Remove MediaPoolItem entry\n        project = lib.get_current_project()\n        media_pool = project.GetMediaPool()\n        item = container[\"_item\"]\n\n        # Delete any usages of the media pool item so there's no trail\n        # left in existing timelines. Currently only the media pool item\n        # gets removed which fits the Resolve workflow but is confusing\n        # artists\n        usage = find_clip_usage(media_pool_item=item, project=project)\n        if usage:\n            # Group all timeline items per timeline, so we can delete the clips\n            # in the timeline at once. The Resolve objects are not hashable, so\n            # we need to store them in the dict by id\n            usage_by_timeline = defaultdict(list)\n            timeline_by_id = {}\n            for timeline, timeline_item in usage:\n                timeline_id = timeline.GetUniqueId()\n                timeline_by_id[timeline_id] = timeline\n                usage_by_timeline[timeline.GetUniqueId()].append(timeline_item)\n\n            for timeline_id, timeline_items in usage_by_timeline.items():\n                timeline = timeline_by_id[timeline_id]\n                timeline.DeleteClips(timeline_items)\n\n        # Delete the media pool item\n        media_pool.DeleteClips([item])\n\n    def _get_container_data(self, context: dict) -&gt; dict:\n        \"\"\"Return metadata related to the representation and version.\"\"\"\n\n        # add additional metadata from the version to imprint AYON knob\n        version = context[\"version\"]\n        data = {}\n\n        # version.attrib\n        for key in [\n            \"frameStart\", \"frameEnd\",\n            \"handleStart\", \"handleEnd\",\n            \"source\", \"fps\", \"colorSpace\"\n        ]:\n            data[key] = version[\"attrib\"][key]\n\n        # version.data\n        for key in [\"author\"]:\n            data[key] = version[\"data\"][key]\n\n        # add variables related to version context\n        data.update({\n            \"representation\": context[\"representation\"][\"id\"],\n            \"version\": version[\"name\"],\n        })\n\n        return data\n\n    @classmethod\n    def get_item_color(cls, context: dict) -&gt; str:\n        \"\"\"Return item color name.\n\n        Coloring depends on whether representation is the latest version.\n        \"\"\"\n        # Compare version with last version\n        # set clip colour\n        if version_is_latest(project_name=context[\"project\"][\"name\"],\n                             version_id=context[\"version\"][\"id\"]):\n            return cls.clip_color_last\n        else:\n            return cls.clip_color_old\n\n    def _set_metadata(self, media_pool_item, context: dict):\n        \"\"\"Set Media Pool Item Clip Properties\"\"\"\n\n        # Set more clip metadata based on the loaded clip's context\n        for meta_item in self.metadata:\n            clip_property = meta_item[\"name\"]\n            value = meta_item[\"value\"]\n            value_formatted = StringTemplate(value).format_strict(context)\n            media_pool_item.SetClipProperty(clip_property, value_formatted)\n\n    def _get_file_info(self, context: dict) -&gt; Tuple[bool, Union[str, dict]]:\n        \"\"\"Return file info for Resolve ImportMedia.\n\n        Args:\n            context (dict): The context dictionary.\n\n        Returns:\n            Tuple[bool, Union[str, dict]]: A tuple of whether the file is a\n                sequence and the file info dictionary.\n        \"\"\"\n\n        representation = context[\"representation\"]\n        anatomy = Anatomy(self._project_name)\n\n        # Get path to representation with correct frame number\n        repre_path = get_representation_path_with_anatomy(\n            representation, anatomy)\n\n        first_frame = representation[\"context\"].get(\"frame\")\n\n        is_sequence = False\n        # is not sequence\n        if first_frame is None:\n            return (\n                is_sequence, {\"FilePath\": repre_path}\n            )\n\n        # This is sequence\n        is_sequence = True\n        repre_files = [\n            file[\"path\"].format(root=anatomy.roots)\n            for file in representation[\"files\"]\n        ]\n\n        # Change frame in representation context to get path with frame\n        #   splitter.\n        representation[\"context\"][\"frame\"] = FRAME_SPLITTER\n        frame_repre_path = get_representation_path_with_anatomy(\n            representation, anatomy\n        )\n        frame_repre_path = Path(frame_repre_path)\n        repre_dir, repre_filename = (\n            frame_repre_path.parent, frame_repre_path.name)\n        # Get sequence prefix and suffix\n        file_prefix, file_suffix = repre_filename.split(FRAME_SPLITTER)\n        # Get frame number from path as string to get frame padding\n        frame_str = str(repre_path)[len(file_prefix):][:len(file_suffix)]\n        frame_padding = len(frame_str)\n\n        file_name = f\"{file_prefix}%0{frame_padding}d{file_suffix}\"\n\n        abs_filepath = Path(repre_dir, file_name)\n\n        start_index = int(first_frame)\n        end_index = int(int(first_frame) + len(repre_files) - 1)\n\n        # See Resolve API, to import for example clip \"file_[001-100].dpx\":\n        # ImportMedia([{\"FilePath\":\"file_%03d.dpx\",\n        #               \"StartIndex\":1,\n        #               \"EndIndex\":100}])\n        return (\n            is_sequence,\n            {\n                \"FilePath\": abs_filepath.as_posix(),\n                \"StartIndex\": start_index,\n                \"EndIndex\": end_index,\n            }\n        )\n\n    def _get_colorspace(self, representation: dict) -&gt; Optional[str]:\n        \"\"\"Return Resolve native colorspace from OCIO colorspace data.\n\n        Returns:\n            Optional[str]: The Resolve native colorspace name, if any mapped.\n        \"\"\"\n\n        data = representation.get(\"data\", {}).get(\"colorspaceData\", {})\n        if not data:\n            return\n\n        ocio_colorspace = data[\"colorspace\"]\n        if not ocio_colorspace:\n            return\n\n        resolve_colorspace = get_remapped_colorspace_to_native(\n            ocio_colorspace_name=ocio_colorspace,\n            host_name=\"resolve\",\n            imageio_host_settings=self._host_imageio_settings\n        )\n        if resolve_colorspace:\n            return resolve_colorspace\n        else:\n            self.log.warning(\n                f\"No mapping from OCIO colorspace '{ocio_colorspace}' \"\n                \"found to a Resolve colorspace. \"\n                \"Ignoring colorspace.\"\n            )\n\n    def _set_colorspace_from_representation(\n            self, media_pool_item, representation: dict):\n        \"\"\"Set the colorspace for the media pool item.\n\n        Args:\n            media_pool_item (MediaPoolItem): The media pool item.\n            representation (dict): The representation data.\n        \"\"\"\n        # Set the Resolve Input Color Space for the media.\n        colorspace = self._get_colorspace(representation)\n        if colorspace:\n            result = set_colorspace(media_pool_item, colorspace)\n            if not result:\n                self.log.warning(\n                    f\"Failed to apply colorspace: {colorspace}.\"\n                )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.LoadMedia.get_item_color","title":"<code>get_item_color(context)</code>  <code>classmethod</code>","text":"<p>Return item color name.</p> <p>Coloring depends on whether representation is the latest version.</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>@classmethod\ndef get_item_color(cls, context: dict) -&gt; str:\n    \"\"\"Return item color name.\n\n    Coloring depends on whether representation is the latest version.\n    \"\"\"\n    # Compare version with last version\n    # set clip colour\n    if version_is_latest(project_name=context[\"project\"][\"name\"],\n                         version_id=context[\"version\"][\"id\"]):\n        return cls.clip_color_last\n    else:\n        return cls.clip_color_old\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.MetadataEntry","title":"<code>MetadataEntry</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Metadata entry is dict with {\"name\": \"key\", \"value: \"value\"}</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>class MetadataEntry(TypedDict):\n    \"\"\"Metadata entry is dict with {\"name\": \"key\", \"value: \"value\"}\"\"\"\n    name: str\n    value: str\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.find_clip_usage","title":"<code>find_clip_usage(media_pool_item, project=None)</code>","text":"<p>Return all Timeline Items in the project using the Media Pool Item.</p> <p>Each entry in the list is a tuple of Timeline and TimelineItem so that it's easy to know which Timeline the TimelineItem belongs to.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>The Media Pool Item to search for.</p> required <code>project</code> <code>Project</code> <p>The resolve project the media pool item resides in.</p> <code>None</code> <p>Returns:</p> Type Description <p>List[Tuple[Timeline, TimelineItem]]: A 2-tuple of a timeline with the timeline item.</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>def find_clip_usage(media_pool_item, project=None):\n    \"\"\"Return all Timeline Items in the project using the Media Pool Item.\n\n    Each entry in the list is a tuple of Timeline and TimelineItem so that\n    it's easy to know which Timeline the TimelineItem belongs to.\n\n    Arguments:\n        media_pool_item (MediaPoolItem): The Media Pool Item to search for.\n        project (Project): The resolve project the media pool item resides in.\n\n    Returns:\n        List[Tuple[Timeline, TimelineItem]]: A 2-tuple of a timeline with\n            the timeline item.\n\n    \"\"\"\n    usage = int(media_pool_item.GetClipProperty(\"Usage\"))\n    if not usage:\n        return []\n\n    if project is None:\n        project = lib.get_current_project()\n\n    matching_items = []\n    unique_id = media_pool_item.GetUniqueId()\n    for timeline_idx in range(project.GetTimelineCount()):\n        timeline = project.GetTimelineByIndex(timeline_idx + 1)\n\n        # Consider audio and video tracks\n        for track_type in [\"video\", \"audio\"]:\n            for track_idx in range(timeline.GetTrackCount(track_type)):\n                timeline_items = timeline.GetItemListInTrack(track_type,\n                                                             track_idx + 1)\n                for timeline_item in timeline_items:\n                    timeline_item_mpi = timeline_item.GetMediaPoolItem()\n                    if not timeline_item_mpi:\n                        continue\n\n                    if timeline_item_mpi.GetUniqueId() == unique_id:\n                        matching_items.append((timeline, timeline_item))\n                        usage -= 1\n                        if usage &lt;= 0:\n                            # If there should be no usage left after this found\n                            # entry we return early\n                            return matching_items\n\n    return matching_items\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.project_color_science_mode","title":"<code>project_color_science_mode(project=None, mode='davinciYRGBColorManagedv2')</code>","text":"<p>Set project color science mode during context.</p> <p>This is especially useful as context for setting the colorspace for media pool items, because when Resolve is not set to <code>davinciYRGBColorManagedv2</code> it fails to set its \"Input Color Space\" clip property even though it is accessible and settable via the Resolve User Interface.</p> <p>Args     project (Project): The active Resolve Project.     mode (Optional[str]): The color science mode to apply during the         context. Defaults to 'davinciYRGBColorManagedv2'</p> See Also <p>https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;t=197441</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>@contextlib.contextmanager\ndef project_color_science_mode(project=None, mode=\"davinciYRGBColorManagedv2\"):\n    \"\"\"Set project color science mode during context.\n\n    This is especially useful as context for setting the colorspace for media\n    pool items, because when Resolve is not set to `davinciYRGBColorManagedv2`\n    it fails to set its \"Input Color Space\" clip property even though it is\n    accessible and settable via the Resolve User Interface.\n\n    Args\n        project (Project): The active Resolve Project.\n        mode (Optional[str]): The color science mode to apply during the\n            context. Defaults to 'davinciYRGBColorManagedv2'\n\n    See Also:\n        https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;t=197441\n    \"\"\"\n\n    if project is None:\n        project = lib.get_current_project()\n\n    original_mode = project.GetSetting(\"colorScienceMode\")\n    if original_mode != mode:\n        project.SetSetting(\"colorScienceMode\", mode)\n    try:\n        yield\n    finally:\n        if project.GetSetting(\"colorScienceMode\") != original_mode:\n            project.SetSetting(\"colorScienceMode\", original_mode)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/load/load_media.html#client.ayon_resolve.plugins.load.load_media.set_colorspace","title":"<code>set_colorspace(media_pool_item, colorspace, mode='davinciYRGBColorManagedv2')</code>","text":"<p>Set MediaPoolItem colorspace.</p> <p>This implements a workaround that you cannot set the input colorspace unless the Resolve project's color science mode is set to <code>davinciYRGBColorManagedv2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>media_pool_item</code> <code>MediaPoolItem</code> <p>The media pool item.</p> required <code>colorspace</code> <code>str</code> <p>The colorspace to apply.</p> required <code>mode</code> <code>Optional[str]</code> <p>The Resolve project color science mode to be in while setting the colorspace. Defaults to 'davinciYRGBColorManagedv2'</p> <code>'davinciYRGBColorManagedv2'</code> <p>Returns:</p> Name Type Description <code>bool</code> <p>Whether applying the colorspace succeeded.</p> Source code in <code>client/ayon_resolve/plugins/load/load_media.py</code> <pre><code>def set_colorspace(media_pool_item,\n                   colorspace,\n                   mode=\"davinciYRGBColorManagedv2\"):\n    \"\"\"Set MediaPoolItem colorspace.\n\n    This implements a workaround that you cannot set the input colorspace\n    unless the Resolve project's color science mode is set to\n    `davinciYRGBColorManagedv2`.\n\n    Args:\n        media_pool_item (MediaPoolItem): The media pool item.\n        colorspace (str): The colorspace to apply.\n        mode (Optional[str]): The Resolve project color science mode to be in\n            while setting the colorspace.\n            Defaults to 'davinciYRGBColorManagedv2'\n\n    Returns:\n        bool: Whether applying the colorspace succeeded.\n    \"\"\"\n    with project_color_science_mode(mode=mode):\n        return media_pool_item.SetClipProperty(\"Input Color Space\", colorspace)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/index.html","title":"publish","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_audio.html","title":"collect_audio","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_audio.html#client.ayon_resolve.plugins.publish.collect_audio.CollectAudio","title":"<code>CollectAudio</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new audio.</p> Source code in <code>client/ayon_resolve/plugins/publish/collect_audio.py</code> <pre><code>class CollectAudio(pyblish.api.InstancePlugin):\n    \"\"\"Collect new audio.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Audio\"\n    hosts = [\"resolve\"]\n    families = [\"audio\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\n                \"Could not retrieve otioClip for audio\"\n                f' {dict(instance.data)}'\n            )\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n\n        try:\n            edit_shared_data = instance.context.data[\"editorialSharedData\"]\n            instance.data.update(\n                edit_shared_data[parent_instance_id]\n            )\n\n        # Ensure shot instance related to the audio instance exists.\n        except KeyError:\n            raise PublishError(\n                f'Could not find shot instance for {instance.data[\"label\"]}.'\n                \" Please ensure it is set and enabled.\"\n            )\n\n        # solve reviewable options\n        review_switch = instance.data[\"creator_attributes\"].get(\"review\")\n\n        if review_switch is True:\n            instance.data[\"reviewAudio\"] = True\n            instance.data.pop(\"review\", None)\n\n        clip_src = instance.data[\"otioClip\"].source_range\n        clip_src_in = clip_src.start_time.to_frames()\n        clip_src_out = clip_src_in + clip_src.duration.to_frames()\n        instance.data.update({\n            \"clipInH\": clip_src_in,\n            \"clipOutH\": clip_src_out\n        })\n\n        self.log.debug(pprint.pformat(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_audio.html#client.ayon_resolve.plugins.publish.collect_audio.CollectAudio.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_resolve/plugins/publish/collect_audio.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\n            \"Could not retrieve otioClip for audio\"\n            f' {dict(instance.data)}'\n        )\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n\n    try:\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n    # Ensure shot instance related to the audio instance exists.\n    except KeyError:\n        raise PublishError(\n            f'Could not find shot instance for {instance.data[\"label\"]}.'\n            \" Please ensure it is set and enabled.\"\n        )\n\n    # solve reviewable options\n    review_switch = instance.data[\"creator_attributes\"].get(\"review\")\n\n    if review_switch is True:\n        instance.data[\"reviewAudio\"] = True\n        instance.data.pop(\"review\", None)\n\n    clip_src = instance.data[\"otioClip\"].source_range\n    clip_src_in = clip_src.start_time.to_frames()\n    clip_src_out = clip_src_in + clip_src.duration.to_frames()\n    instance.data.update({\n        \"clipInH\": clip_src_in,\n        \"clipOutH\": clip_src_out\n    })\n\n    self.log.debug(pprint.pformat(instance.data))\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_current_project.html","title":"collect_current_project","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_current_project.html#client.ayon_resolve.plugins.publish.collect_current_project.CollectResolveProject","title":"<code>CollectResolveProject</code>","text":"<p>               Bases: <code>ContextPlugin</code></p> <p>Collect the current Resolve project and current timeline data</p> Source code in <code>client/ayon_resolve/plugins/publish/collect_current_project.py</code> <pre><code>class CollectResolveProject(pyblish.api.ContextPlugin):\n    \"\"\"Collect the current Resolve project and current timeline data\"\"\"\n\n    label = \"Collect Project and Current Timeline\"\n    order = pyblish.api.CollectorOrder - 0.499\n    hosts = [\"resolve\"]\n\n    def process(self, context):\n        resolve_project = api.get_current_resolve_project()\n        timeline = resolve_project.GetCurrentTimeline()\n\n        video_tracks = api.get_video_track_names()\n        otio_timeline = api.export_timeline_otio(timeline)\n\n        host = registered_host()        \n        current_file = host.get_current_workfile()\n        fps = timeline.GetSetting(\"timelineFrameRate\")\n\n        # update context with main project attributes\n        context.data.update({\n            # project\n            \"activeProject\": resolve_project,\n            \"currentFile\": current_file,\n            # timeline\n            \"otioTimeline\": otio_timeline,\n            \"videoTracks\": video_tracks,\n            \"fps\": fps,\n        })\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_editorial_package.html","title":"collect_editorial_package","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_editorial_package.html#client.ayon_resolve.plugins.publish.collect_editorial_package.EditorialPackageInstances","title":"<code>EditorialPackageInstances</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect all Track items selection.</p> Source code in <code>client/ayon_resolve/plugins/publish/collect_editorial_package.py</code> <pre><code>class EditorialPackageInstances(pyblish.api.InstancePlugin):\n    \"\"\"Collect all Track items selection.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Collect Editorial Package Instances\"\n    families = [\"editorial_pkg\"]\n\n    def process(self, instance):\n        project_name = instance.context.data[\"projectName\"]\n        self.log.info(f\"project: {project_name}\")\n\n        media_pool_item = instance.data[\"transientData\"][\"timeline_pool_item\"]\n\n        # Special case for versioning editorial_pkg products:\n        # * instance created by creator: version up as usual\n        # * instance created from loader: loaded version is added \n        #   into the instance by loader. Then version up from initial pkg\n        #   to keep 'chained' version across tasks/product when possible.\n        version = instance.data.get(\"version\")\n        if version is not None:\n            # get version from publish data and rise it one up\n            version += 1\n\n            # make sure last version of product is higher than current\n            # expected current version from publish data\n            folder_entity = ayon_api.get_folder_by_path(\n                project_name=project_name,\n                folder_path=instance.data[\"folderPath\"],\n            )\n            last_version = ayon_api.get_last_version_by_product_name(\n                project_name=project_name,\n                product_name=instance.data[\"productName\"],\n                folder_id=folder_entity[\"id\"],\n            )\n            if last_version is not None:\n                last_version = int(last_version[\"version\"])\n                if version &lt;= last_version:\n                    version = last_version + 1\n\n            instance.data[\"version\"] = version\n\n        with maintain_current_timeline(media_pool_item) as timeline:\n            instance.data.update(\n                {\n                    \"mediaPoolItem\": media_pool_item,\n                    \"item\": media_pool_item,\n                    \"fps\": timeline.GetSetting(\"timelineFrameRate\"),\n                    \"frameStart\": timeline.GetStartFrame(),\n                    \"frameEnd\": timeline.GetEndFrame()\n                }\n            )\n\n        # Shall the instance produce reviewable representation ?\n        creator_attributes = instance.data.get(\"creator_attributes\", {})\n        reviewable = creator_attributes.pop(\"review\", False)\n        if reviewable:\n            instance.data[\"families\"].append(\"review\")\n\n        self.log.debug(f\"Editorial Package: {instance.data}\")\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_plates.html","title":"collect_plates","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_plates.html#client.ayon_resolve.plugins.publish.collect_plates.CollectPlate","title":"<code>CollectPlate</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new plates.</p> Source code in <code>client/ayon_resolve/plugins/publish/collect_plates.py</code> <pre><code>class CollectPlate(pyblish.api.InstancePlugin):\n    \"\"\"Collect new plates.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.48\n    label = \"Collect Plate\"\n    hosts = [\"resolve\"]\n    families = [\"plate\"]\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"families\"].append(\"clip\")\n\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\n                \"Could not retrieve otioClip for plate\"\n                f' {dict(instance.data)}'\n            )\n\n        instance.data[\"otioClip\"] = otio_clip\n\n        # solve reviewable options\n        review_switch = instance.data[\"creator_attributes\"].get(\n            \"review\")\n        reviewable_source = instance.data[\"creator_attributes\"].get(\n            \"reviewableSource\")\n\n        if review_switch is True:\n            if reviewable_source == \"clip_media\":\n                instance.data[\"families\"].append(\"review\")\n                instance.data.pop(\"reviewTrack\", None)\n            else:\n                instance.data[\"reviewTrack\"] = reviewable_source\n\n        # remove creator-specific review keys from instance data\n        instance.data.pop(\"reviewableSource\", None)\n        instance.data.pop(\"review\", None)\n\n        # Retrieve instance data from parent instance shot instance.\n        parent_instance_id = instance.data[\"parent_instance_id\"]\n\n        try:\n            edit_shared_data = instance.context.data[\"editorialSharedData\"]\n            instance.data.update(\n                edit_shared_data[parent_instance_id]\n            )\n\n        # Ensure shot instance related to the audio instance exists.\n        except KeyError:\n            raise PublishError(\n                f'Could not find shot instance for {instance.data[\"label\"]}.'\n                \" Please ensure it is set and enabled.\"\n            )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_plates.html#client.ayon_resolve.plugins.publish.collect_plates.CollectPlate.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_resolve/plugins/publish/collect_plates.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"families\"].append(\"clip\")\n\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\n            \"Could not retrieve otioClip for plate\"\n            f' {dict(instance.data)}'\n        )\n\n    instance.data[\"otioClip\"] = otio_clip\n\n    # solve reviewable options\n    review_switch = instance.data[\"creator_attributes\"].get(\n        \"review\")\n    reviewable_source = instance.data[\"creator_attributes\"].get(\n        \"reviewableSource\")\n\n    if review_switch is True:\n        if reviewable_source == \"clip_media\":\n            instance.data[\"families\"].append(\"review\")\n            instance.data.pop(\"reviewTrack\", None)\n        else:\n            instance.data[\"reviewTrack\"] = reviewable_source\n\n    # remove creator-specific review keys from instance data\n    instance.data.pop(\"reviewableSource\", None)\n    instance.data.pop(\"review\", None)\n\n    # Retrieve instance data from parent instance shot instance.\n    parent_instance_id = instance.data[\"parent_instance_id\"]\n\n    try:\n        edit_shared_data = instance.context.data[\"editorialSharedData\"]\n        instance.data.update(\n            edit_shared_data[parent_instance_id]\n        )\n\n    # Ensure shot instance related to the audio instance exists.\n    except KeyError:\n        raise PublishError(\n            f'Could not find shot instance for {instance.data[\"label\"]}.'\n            \" Please ensure it is set and enabled.\"\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_shots.html","title":"collect_shots","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_shots.html#client.ayon_resolve.plugins.publish.collect_shots.CollectShot","title":"<code>CollectShot</code>","text":"<p>               Bases: <code>InstancePlugin</code></p> <p>Collect new shots.</p> Source code in <code>client/ayon_resolve/plugins/publish/collect_shots.py</code> <pre><code>class CollectShot(pyblish.api.InstancePlugin):\n    \"\"\"Collect new shots.\"\"\"\n\n    order = pyblish.api.CollectorOrder - 0.49\n    label = \"Collect Shots\"\n    hosts = [\"resolve\"]\n    families = [\"shot\"]\n\n    SHARED_KEYS = (\n        \"folderPath\",\n        \"fps\",\n        \"resolutionWidth\",\n        \"resolutionHeight\",\n        \"pixelAspect\",\n    )\n\n    @classmethod\n    def _inject_editorial_shared_data(cls, instance):\n        \"\"\"\n        Args:\n            instance (obj): The publishing instance.\n        \"\"\"\n        context = instance.context\n        instance_id = instance.data[\"instance_id\"]\n\n        # Inject folderPath and other creator_attributes to ensure\n        # new shots/hierarchy are properly handled.\n        creator_attributes = instance.data['creator_attributes']\n        instance.data.update(creator_attributes)\n\n        # Inject/Distribute instance shot data as editorialSharedData\n        # to make it available for clip/plate/audio products\n        # in sub-collectors.\n        if not context.data.get(\"editorialSharedData\"):\n            context.data[\"editorialSharedData\"] = {}\n\n        context.data[\"editorialSharedData\"][instance_id] = {\n            key: value for key, value in instance.data.items()\n            if key in cls.SHARED_KEYS\n        }\n\n    def process(self, instance):\n        \"\"\"\n        Args:\n            instance (pyblish.Instance): The shot instance to update.\n        \"\"\"\n        instance.data[\"integrate\"] = False  # no representation for shot\n\n        # Adjust instance data from parent otio timeline.\n        otio_timeline = instance.context.data[\"otioTimeline\"]\n        otio_clip, marker = utils.get_marker_from_clip_index(\n            otio_timeline, instance.data[\"clip_index\"]\n        )\n        if not otio_clip:\n            raise PublishError(\"Could not retrieve otioClip for shot %r\", instance)\n\n        # Compute fps from creator attribute.\n        if instance.data['creator_attributes'][\"fps\"] == \"from_selection\":\n            instance.data['creator_attributes'][\"fps\"] = instance.context.data[\"fps\"]\n\n        # Retrieve AyonData marker for associated clip.\n        instance.data[\"otioClip\"] = otio_clip\n        creator_id = instance.data[\"creator_identifier\"]\n        inst_data = marker.metadata[\"resolve_sub_products\"].get(creator_id, {})\n\n        # Overwrite settings with clip metadata is \"sourceResolution\"\n        overwrite_clip_metadata = inst_data.get(\"sourceResolution\", False)\n        if overwrite_clip_metadata:\n            clip_metadata = inst_data[\"clip_source_resolution\"]\n            width = clip_metadata[\"width\"]\n            height = clip_metadata[\"height\"]\n            pixel_aspect = clip_metadata[\"pixelAspect\"]\n\n        else:\n            # AYON's OTIO export = resolution from timeline metadata.\n            # This is metadata is inserted by ayon_resolve.otio.davinci_export.\n            width = height = None\n            try:\n                width = otio_timeline.metadata[\"width\"]\n                height = otio_timeline.metadata[\"height\"]\n                pixel_aspect = otio_timeline.metadata[\"pixelAspect\"]\n\n            except KeyError:\n                # Retrieve resolution for project.\n                project = lib.get_current_project()\n                project_settings = project.GetSetting()\n                try:\n                    pixel_aspect = int(project_settings[\"timelinePixelAspectRatio\"])\n                except ValueError:\n                    pixel_aspect = 1.0\n\n                width = int(project_settings[\"timelineResolutionWidth\"])\n                height = int(project_settings[\"timelineResolutionHeight\"])\n\n        instance.data.update(\n            {\n                \"resolutionWidth\": width,\n                \"resolutionHeight\": height,\n                \"pixelAspect\": pixel_aspect,\n            }\n        )\n\n        self._inject_editorial_shared_data(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/collect_shots.html#client.ayon_resolve.plugins.publish.collect_shots.CollectShot.process","title":"<code>process(instance)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>instance</code> <code>Instance</code> <p>The shot instance to update.</p> required Source code in <code>client/ayon_resolve/plugins/publish/collect_shots.py</code> <pre><code>def process(self, instance):\n    \"\"\"\n    Args:\n        instance (pyblish.Instance): The shot instance to update.\n    \"\"\"\n    instance.data[\"integrate\"] = False  # no representation for shot\n\n    # Adjust instance data from parent otio timeline.\n    otio_timeline = instance.context.data[\"otioTimeline\"]\n    otio_clip, marker = utils.get_marker_from_clip_index(\n        otio_timeline, instance.data[\"clip_index\"]\n    )\n    if not otio_clip:\n        raise PublishError(\"Could not retrieve otioClip for shot %r\", instance)\n\n    # Compute fps from creator attribute.\n    if instance.data['creator_attributes'][\"fps\"] == \"from_selection\":\n        instance.data['creator_attributes'][\"fps\"] = instance.context.data[\"fps\"]\n\n    # Retrieve AyonData marker for associated clip.\n    instance.data[\"otioClip\"] = otio_clip\n    creator_id = instance.data[\"creator_identifier\"]\n    inst_data = marker.metadata[\"resolve_sub_products\"].get(creator_id, {})\n\n    # Overwrite settings with clip metadata is \"sourceResolution\"\n    overwrite_clip_metadata = inst_data.get(\"sourceResolution\", False)\n    if overwrite_clip_metadata:\n        clip_metadata = inst_data[\"clip_source_resolution\"]\n        width = clip_metadata[\"width\"]\n        height = clip_metadata[\"height\"]\n        pixel_aspect = clip_metadata[\"pixelAspect\"]\n\n    else:\n        # AYON's OTIO export = resolution from timeline metadata.\n        # This is metadata is inserted by ayon_resolve.otio.davinci_export.\n        width = height = None\n        try:\n            width = otio_timeline.metadata[\"width\"]\n            height = otio_timeline.metadata[\"height\"]\n            pixel_aspect = otio_timeline.metadata[\"pixelAspect\"]\n\n        except KeyError:\n            # Retrieve resolution for project.\n            project = lib.get_current_project()\n            project_settings = project.GetSetting()\n            try:\n                pixel_aspect = int(project_settings[\"timelinePixelAspectRatio\"])\n            except ValueError:\n                pixel_aspect = 1.0\n\n            width = int(project_settings[\"timelineResolutionWidth\"])\n            height = int(project_settings[\"timelineResolutionHeight\"])\n\n    instance.data.update(\n        {\n            \"resolutionWidth\": width,\n            \"resolutionHeight\": height,\n            \"pixelAspect\": pixel_aspect,\n        }\n    )\n\n    self._inject_editorial_shared_data(instance)\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_editorial_package.html","title":"extract_editorial_package","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_editorial_package.html#client.ayon_resolve.plugins.publish.extract_editorial_package.ExtractEditorialPackage","title":"<code>ExtractEditorialPackage</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract and Render intermediate file for Editorial Package</p> Source code in <code>client/ayon_resolve/plugins/publish/extract_editorial_package.py</code> <pre><code>class ExtractEditorialPackage(publish.Extractor):\n    \"\"\"\n    Extract and Render intermediate file for Editorial Package\n\n    \"\"\"\n\n    label = \"Extract Editorial Package\"\n    order = pyblish.api.ExtractorOrder + 0.45\n    families = [\"editorial_pkg\"]\n\n    def process(self, instance):\n        # create representation data\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        anatomy = instance.context.data[\"anatomy\"]\n        folder_path = instance.data[\"folderPath\"]\n        timeline_mp_item = instance.data[\"mediaPoolItem\"]\n        timeline_name = timeline_mp_item.GetName()\n        folder_path_name = folder_path.lstrip(\"/\").replace(\"/\", \"_\")\n\n        staging_dir = Path(self.staging_dir(instance))\n        subfolder_name = folder_path_name + \"_\" + timeline_name\n\n        # new staging directory for each timeline\n        staging_dir = staging_dir / subfolder_name\n        self.log.info(f\"Staging directory: {staging_dir}\")\n\n        # otio file path\n        otio_file_path = staging_dir / f\"{subfolder_name}.otio\"\n\n        # if timeline was used then switch it to current timeline\n        with maintain_current_timeline(timeline_mp_item) as timeline:\n            timeline_fps = timeline.GetSetting(\"timelineFrameRate\")\n            timeline_start_frame = timeline.GetStartFrame()\n            timeline_end_frame = timeline.GetEndFrame()\n            timeline_duration = timeline_end_frame - timeline_start_frame\n            self.log.info(\n                f\"Timeline: {timeline}, \"\n                f\"Start: {timeline_start_frame}, \"\n                f\"End: {timeline_end_frame}, \"\n                f\"Duration: {timeline_duration}, \"\n                f\"FPS: {timeline_fps}\"\n            )\n\n            # export otio representation\n            self.export_otio_representation(\n                get_current_project(), timeline, otio_file_path\n            )\n\n        # Find Intermediate file representation file name\n        published_file_path = None\n        for repre in instance.data[\"representations\"]:\n            if repre[\"name\"] == \"intermediate\":\n                published_file_path = self._get_published_path(instance, repre)\n                break\n\n        if published_file_path is None:\n            raise ValueError(\"Intermediate representation not found\")\n\n        # Finding clip references and replacing them with rootless paths\n        # of video files\n        otio_timeline = otio.adapters.read_from_file(otio_file_path.as_posix())\n        for track in otio_timeline.tracks:\n            for clip in track:\n                # skip transitions\n                if isinstance(clip, otio.schema.Transition):\n                    continue\n                # skip gaps\n                if isinstance(clip, otio.schema.Gap):\n                    # get duration of gap\n                    continue\n\n                if hasattr(clip.media_reference, \"target_url\"):\n                    path_to_media = Path(published_file_path)\n                    # remove root from path\n                    success, rootless_path = anatomy.find_root_template_from_path(  # noqa\n                        path_to_media.as_posix()\n                    )\n                    if success:\n                        media_source_path = rootless_path\n                    else:\n                        media_source_path = path_to_media.as_posix()\n\n                    new_media_reference = otio.schema.ExternalReference(\n                        target_url=media_source_path,\n                        available_range=otio.opentime.TimeRange(\n                            start_time=otio.opentime.RationalTime(\n                                value=timeline_start_frame, rate=timeline_fps\n                            ),\n                            duration=otio.opentime.RationalTime(\n                                value=timeline_duration, rate=timeline_fps\n                            ),\n                        ),\n                    )\n                    clip.media_reference = new_media_reference\n\n                    # replace clip source range with track parent range\n                    clip.source_range = otio.opentime.TimeRange(\n                        start_time=otio.opentime.RationalTime(\n                            value=(\n                                timeline_start_frame\n                                + clip.range_in_parent().start_time.value\n                            ),\n                            rate=timeline_fps,\n                        ),\n                        duration=clip.range_in_parent().duration,\n                    )\n\n        # reference video representations also needs to reframe available\n        # frames and clip source\n\n        # new otio file needs to be saved as new file\n        otio_file_path_replaced = staging_dir / f\"{subfolder_name}_remap.otio\"\n        otio.adapters.write_to_file(\n            otio_timeline, otio_file_path_replaced.as_posix())\n\n        self.log.debug(\n            f\"OTIO file with replaced references: {otio_file_path_replaced}\")\n\n        # create drp workfile representation\n        representation_otio = {\n            \"name\": \"editorial_pkg\",\n            \"ext\": \"otio\",\n            \"files\": f\"{subfolder_name}_remap.otio\",\n            \"stagingDir\": staging_dir.as_posix(),\n        }\n        self.log.debug(f\"OTIO representation: {representation_otio}\")\n        instance.data[\"representations\"].append(representation_otio)\n\n        self.log.info(\n            \"Added OTIO file representation: \"\n            f\"{otio_file_path}\"\n        )\n\n    def export_otio_representation(self, resolve_project, timeline, filepath):\n        # Native otio export is available from Resolve 18.5\n        # [major, minor, patch, build, suffix]\n        resolve_version = bmdvr.GetVersion()\n        if resolve_version[0] &lt; 18 or resolve_version[1] &lt; 5:\n            # if it is lower then use ayon's otio exporter\n            otio_timeline = davinci_export.create_otio_timeline(\n                resolve_project, timeline=timeline\n            )\n            davinci_export.write_to_file(otio_timeline, filepath.as_posix())\n        else:\n            # use native otio export\n            export_timeline_otio_native(timeline, filepath.as_posix())\n\n        # check if file exists\n        if not filepath.exists():\n            raise FileNotFoundError(f\"OTIO file not found: {filepath}\")\n\n    def _get_published_path(self, instance, representation):\n        \"\"\"Calculates expected `publish` folder\"\"\"\n        # determine published path from Anatomy.\n        template_data = instance.data.get(\"anatomyData\")\n\n        template_data[\"representation\"] = representation[\"name\"]\n        template_data[\"ext\"] = representation[\"ext\"]\n        template_data[\"comment\"] = None\n\n        anatomy = instance.context.data[\"anatomy\"]\n        template_data[\"root\"] = anatomy.roots\n        template = anatomy.get_template_item(\"publish\", \"default\", \"path\")\n        template_filled = template.format_strict(template_data)\n        file_path = Path(template_filled)\n        return file_path.as_posix()\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_intermediate_representation.html","title":"extract_intermediate_representation","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_intermediate_representation.html#client.ayon_resolve.plugins.publish.extract_intermediate_representation.ExtractIntermediateRepresentation","title":"<code>ExtractIntermediateRepresentation</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extract and Render intermediate file for Editorial Package</p> Source code in <code>client/ayon_resolve/plugins/publish/extract_intermediate_representation.py</code> <pre><code>class ExtractIntermediateRepresentation(publish.Extractor):\n    \"\"\"\n    Extract and Render intermediate file for Editorial Package\n\n    \"\"\"\n\n    label = \"Extract Intermediate Representation\"\n    order = pyblish.api.ExtractorOrder - 0.45\n    families = [\"editorial_pkg\"]\n\n    # Settings\n    file_format = \"QuickTime\"\n    codec = \"H.264\"\n    preset_name = \"AYON_intermediates\"\n\n    def process(self, instance):\n        # create representation data\n        if \"representations\" not in instance.data:\n            instance.data[\"representations\"] = []\n\n        folder_path = instance.data[\"folderPath\"]\n        timeline_mp_item = instance.data[\"mediaPoolItem\"]\n        timeline_name = timeline_mp_item.GetName()\n        folder_path_name = folder_path.lstrip(\"/\").replace(\"/\", \"_\")\n\n        staging_dir = self.staging_dir(instance)\n\n        subfolder_name = folder_path_name + \"_\" + timeline_name\n\n        staging_dir = os.path.normpath(\n            os.path.join(staging_dir, subfolder_name))\n\n        self.log.info(f\"Staging directory: {staging_dir}\")\n\n        self.log.info(f\"Timeline: {timeline_mp_item}\")\n        self.log.info(f\"Timeline name: {timeline_name}\")\n        # if timeline was used then switch it to current timeline\n        with maintain_current_timeline(timeline_mp_item) as timeline:\n            self.log.info(f\"Timeline: {timeline}\")\n            self.log.info(f\"Timeline name: {timeline.GetName()}\")\n\n            # Render timeline here\n            rendered_file = self.render_timeline_intermediate_file(\n                timeline,\n                Path(staging_dir),\n            )\n\n        self.log.debug(f\"Rendered file: {rendered_file}\")\n\n        # create intermediate workfile representation\n        representation_intermediate = {\n            \"name\": \"intermediate\",\n            \"ext\": os.path.splitext(rendered_file)[1][1:],\n            \"files\": rendered_file.name,\n            \"stagingDir\": staging_dir,\n            \"tags\": [\"review\"]\n        }\n        self.log.debug(f\"Video representation: {representation_intermediate}\")\n        instance.data[\"representations\"].append(representation_intermediate)\n\n        self.log.info(\n            \"Added intermediate file representation: \"\n            f\"{os.path.join(staging_dir, rendered_file)}\"\n        )\n\n    def render_timeline_intermediate_file(\n        self,\n        timeline,\n        target_render_directory,\n    ):\n        \"\"\"Render timeline to intermediate file\n\n        Process is taking a defined timeline and render it to temporary\n        intermediate file which will be lately used by Extract Review plugin\n        for conversion to review file.\n        \"\"\"\n        # get path to ayon_resolve module and get path to render presets\n        render_preset_path = Path(\n            RESOLVE_ADDON_ROOT, \"presets\", \"render\", f\"{self.preset_name}.xml\"\n        )\n\n        self.log.info(f\"Rendering timeline to '{target_render_directory}'\")\n\n        with maintain_page_by_name(\"Deliver\"):\n            # first we need to maintain rendering preset\n            if not set_render_preset_from_file(render_preset_path.as_posix()):\n                raise Exception(\"Unable to add render preset.\")\n\n            # set render format and codec\n            format_extension = set_format_and_codec(\n                self.file_format, self.codec)\n\n            if not format_extension:\n                raise Exception(\"Unable to set render format and codec.\")\n\n            if not render_single_timeline(\n                timeline,\n                target_render_directory,\n            ):\n                raise Exception(\"Unable to render timeline.\")\n\n        # get path of the rendered file\n        rendered_files = list(\n            target_render_directory.glob(f\"*.{format_extension}\"))\n\n        if not rendered_files:\n            raise Exception(\"No rendered files found.\")\n\n        return rendered_files[0]\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_intermediate_representation.html#client.ayon_resolve.plugins.publish.extract_intermediate_representation.ExtractIntermediateRepresentation.render_timeline_intermediate_file","title":"<code>render_timeline_intermediate_file(timeline, target_render_directory)</code>","text":"<p>Render timeline to intermediate file</p> <p>Process is taking a defined timeline and render it to temporary intermediate file which will be lately used by Extract Review plugin for conversion to review file.</p> Source code in <code>client/ayon_resolve/plugins/publish/extract_intermediate_representation.py</code> <pre><code>def render_timeline_intermediate_file(\n    self,\n    timeline,\n    target_render_directory,\n):\n    \"\"\"Render timeline to intermediate file\n\n    Process is taking a defined timeline and render it to temporary\n    intermediate file which will be lately used by Extract Review plugin\n    for conversion to review file.\n    \"\"\"\n    # get path to ayon_resolve module and get path to render presets\n    render_preset_path = Path(\n        RESOLVE_ADDON_ROOT, \"presets\", \"render\", f\"{self.preset_name}.xml\"\n    )\n\n    self.log.info(f\"Rendering timeline to '{target_render_directory}'\")\n\n    with maintain_page_by_name(\"Deliver\"):\n        # first we need to maintain rendering preset\n        if not set_render_preset_from_file(render_preset_path.as_posix()):\n            raise Exception(\"Unable to add render preset.\")\n\n        # set render format and codec\n        format_extension = set_format_and_codec(\n            self.file_format, self.codec)\n\n        if not format_extension:\n            raise Exception(\"Unable to set render format and codec.\")\n\n        if not render_single_timeline(\n            timeline,\n            target_render_directory,\n        ):\n            raise Exception(\"Unable to render timeline.\")\n\n    # get path of the rendered file\n    rendered_files = list(\n        target_render_directory.glob(f\"*.{format_extension}\"))\n\n    if not rendered_files:\n        raise Exception(\"No rendered files found.\")\n\n    return rendered_files[0]\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_workfile.html","title":"extract_workfile","text":""},{"location":"autoapi/client/ayon_resolve/plugins/publish/extract_workfile.html#client.ayon_resolve.plugins.publish.extract_workfile.ExtractWorkfile","title":"<code>ExtractWorkfile</code>","text":"<p>               Bases: <code>Extractor</code></p> <p>Extractor export DRP workfile file representation</p> Source code in <code>client/ayon_resolve/plugins/publish/extract_workfile.py</code> <pre><code>class ExtractWorkfile(publish.Extractor):\n    \"\"\"\n    Extractor export DRP workfile file representation\n    \"\"\"\n\n    label = \"Extract Workfile\"\n    order = pyblish.api.ExtractorOrder\n    families = [\"workfile\"]\n    hosts = [\"resolve\"]\n\n    def process(self, instance):\n        project = instance.context.data[\"activeProject\"]\n\n        drp_file_path = instance.context.data[\"currentFile\"]\n        drp_file_name = os.path.basename(drp_file_path)\n\n        # write out the drp workfile\n        get_project_manager().ExportProject(\n            project.GetName(), drp_file_path)\n\n        # create drp workfile representation\n        representation_drp = {\n            'name': \"drp\",\n            'ext': \"drp\",\n            'files': drp_file_name,\n            \"stagingDir\": os.path.dirname(drp_file_path),\n        }\n        representations = instance.data.setdefault(\"representations\", [])\n        representations.append(representation_drp)\n\n        # add sourcePath attribute to instance\n        if not instance.data.get(\"sourcePath\"):\n            instance.data[\"sourcePath\"] = drp_file_path\n\n        self.log.debug(\n            \"Added Resolve file representation: {}\".format(representation_drp)\n        )\n</code></pre>"},{"location":"autoapi/client/ayon_resolve/utility_scripts/index.html","title":"utility_scripts","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/AYON__Menu.html","title":"AYON__Menu","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/develop/index.html","title":"develop","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/develop/OTIO_export.html","title":"OTIO_export","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/develop/OTIO_import.html","title":"OTIO_import","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/develop/OpenPype_sync_util_scripts.html","title":"OpenPype_sync_util_scripts","text":""},{"location":"autoapi/client/ayon_resolve/utility_scripts/develop/test_rendering_editorial_package.html","title":"test_rendering_editorial_package","text":""},{"location":"autoapi/server/index.html","title":"server","text":""},{"location":"autoapi/server/imageio.html","title":"imageio","text":""},{"location":"autoapi/server/settings.html","title":"settings","text":""},{"location":"autoapi/server/settings.html#server.settings.MetadataMappingModel","title":"<code>MetadataMappingModel</code>","text":"<p>               Bases: <code>BaseSettingsModel</code></p> <p>Metadata mapping</p> <p>Representation document context data are used for formatting of anatomy tokens. Following are supported: - version - task - asset</p> Source code in <code>server/settings.py</code> <pre><code>class MetadataMappingModel(BaseSettingsModel):\n    \"\"\"Metadata mapping\n\n    Representation document context data are used for formatting of\n    anatomy tokens. Following are supported:\n    - version\n    - task\n    - asset\n\n    \"\"\"\n    name: str = SettingsField(\n        \"\",\n        title=\"Metadata property name\"\n    )\n    value: str = SettingsField(\n        \"\",\n        title=\"Metadata value template\"\n    )\n</code></pre>"}]}